#!/bin/sh

# Copyright (c) 2021-2023 åˆ˜å¯Œé¢‘
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.


# https://github.com/leleliu008/xcpkg

_0=$0

unset CURRENT_SCRIPT_DIR
unset CURRENT_SCRIPT_FILENAME
unset CURRENT_SCRIPT_FILEPATH

CURRENT_SCRIPT_DIR=$(cd "$(dirname "$0")" && pwd) || exit 1
CURRENT_SCRIPT_FILENAME=$(basename "$0")
CURRENT_SCRIPT_FILEPATH="$CURRENT_SCRIPT_DIR/$CURRENT_SCRIPT_FILENAME"


COLOR_RED='\033[0;31m'          # Red
COLOR_GREEN='\033[0;32m'        # Green
COLOR_YELLOW='\033[0;33m'       # Yellow
COLOR_BLUE='\033[0;94m'         # Blue
COLOR_PURPLE='\033[0;35m'       # Purple
COLOR_OFF='\033[0m'             # Reset

print() {
    printf '%b' "$*"
}

echo() {
    printf '%b\n' "$*"
}

info() {
    printf '%b\n' "ðŸ’   $*"
}

note() {
    printf '%b\n' "${COLOR_YELLOW}ðŸ””  $*${COLOR_OFF}" >&2
}

warn() {
    printf '%b\n' "${COLOR_YELLOW}ðŸ”¥  $*${COLOR_OFF}" >&2
}

success() {
    printf '%b\n' "${COLOR_GREEN}[âœ”] $*${COLOR_OFF}"
}

error() {
    printf '%b\n' "${COLOR_RED}ðŸ’”  $*${COLOR_OFF}" >&2
}

die() {
    printf '%b\n' "${COLOR_RED}ðŸ’”  $*${COLOR_OFF}" >&2
    exit 1
}

bppend_to_PATH() {
    case ":${PATH}:" in
        *:"$1":*) ;;
        *) export PATH="$1:$PATH" ;;
    esac
}

bppend_to_ACLOCAL_PATH() {
    case ":${ACLOCAL_PATH}:" in
        *:"$1":*) ;;
        *) export ACLOCAL_PATH="$1:$ACLOCAL_PATH" ;;
    esac
}

# check if file exists
# $1 FILEPATH
file_exists() {
    [ -n "$1" ] && [ -e "$1" ]
}

# check if command exists in filesystem
# $1 command name or path
command_exists_in_filesystem() {
    case $1 in
        '') return 1 ;;
        */*)
            case $(uname | tr A-Z a-z) in
                cygwin*)
                    case $1 in
                        /cygdrive/*/choco) executable "$1" ;;
                        /cygdrive/*) return 1 ;;
                        *) executable "$1" ;;
                    esac
                    ;;
                *) executable "$1" ;;
            esac
            ;;
        *)  command_exists_in_filesystem $(command -v "$1" || true)
    esac
}

executable() {
    file_exists "$1" && [ -x "$1" ]
}

die_if_file_is_not_exist() {
    file_exists "$1" || die "$1 is not exist."
}

die_if_not_executable() {
    executable "$1" || die "$1 is not executable."
}

step() {
    STEP_NUM=$(expr ${STEP_NUM-0} + 1)
    STEP_MESSAGE="$@"
    echo
    echo "${COLOR_PURPLE}=>> STEP ${STEP_NUM} : ${STEP_MESSAGE} ${COLOR_OFF}"
}

run() {
    echo "${COLOR_PURPLE}==>${COLOR_OFF} ${COLOR_GREEN}$@${COLOR_OFF}"
    eval "$*"
}

list() {
    for item in $@
    do
        echo "$item"
    done
}

list_length() {
    echo $#
}

shiftn() {
    shift "$1" && shift && echo "$@"
}

sed_in_place() {
    if command -v gsed > /dev/null ; then
        unset SED_IN_PLACE_ACTION
        SED_IN_PLACE_ACTION="$1"
        shift
        # contains ' but not contains \'
        if printf "$SED_IN_PLACE_ACTION" | hexdump -v -e '1/1 "%02X" " "' | grep -q 27 && ! printf "$SED_IN_PLACE_ACTION" | hexdump -v -e '1/1 "%02X" ""' | grep -q '5C 27' ; then
            run gsed -i "\"$SED_IN_PLACE_ACTION\"" $@
        else
            run gsed -i "'$SED_IN_PLACE_ACTION'" $@
        fi
    elif command -v sed  > /dev/null ; then
        if sed -i 's/a/b/g' $(mktemp) 2> /dev/null ; then
            unset SED_IN_PLACE_ACTION
            SED_IN_PLACE_ACTION="$1"
            shift
            if printf "$SED_IN_PLACE_ACTION" | hexdump -v -e '1/1 "%02X" " "' | grep -q 27 && ! printf "$SED_IN_PLACE_ACTION" | hexdump -v -e '1/1 "%02X" ""' | grep -q '5C 27' ; then
                run sed -i "\"$SED_IN_PLACE_ACTION\"" $@
            else
                run sed -i "'$SED_IN_PLACE_ACTION'" $@
            fi
        else
            unset SED_IN_PLACE_ACTION
            SED_IN_PLACE_ACTION="$1"
            shift
            if printf "$SED_IN_PLACE_ACTION" | hexdump -v -e '1/1 "%02X" " "' | grep -q 27 && ! printf "$SED_IN_PLACE_ACTION" | hexdump -v -e '1/1 "%02X" ""' | grep -q '5C 27' ; then
                run sed -i '""' "\"$SED_IN_PLACE_ACTION\"" $@
            else
                run sed -i '""' "'$SED_IN_PLACE_ACTION'" $@
            fi
        fi
    else
        die "please install sed utility."
    fi
}

getvalue() {
    if [ $# -eq 0 ] ; then
        cut -d= -f2
    else
        printf '%s\n' "$1" | cut -d= -f2
    fi
}

is_integer() {
    case "${1#[+-]}" in
        (*[!0123456789]*) return 1 ;;
        ('')              return 1 ;;
        (*)               return 0 ;;
    esac
}

# format_unix_timestamp <TIMESTAMP-UNIX> <TO-FORMAT> [-u]
  format_unix_timestamp() {
   date $3 -jf "%s" "$1" "$2" 2> /dev/null ||
   date $3 -d      "@$1" "$2"
}

# https://equa.space/sh/lolcat/
lolcat_awk() {
    awk -v angle=45 -v angle_phase=40 -v reverse=0 -v offset=195 -v offset_phase=0 -v width=100 -v width_phase=8 "$@" '
    function put_rgb(color) {
        printf "\033[%s38;2;%d;%d;%dm", reverse ? "7;" : "", int(color[1] * 255), int(color[2] * 255), int(color[3] * 255);
    }

    function hsv_to_rgb(hsv, rgb, c, h2, x) {
        c = hsv[2] * hsv[3];
        h2 = hsv[1] * 6;
        x = c * (1 - ((h2 % 2) - 1 > 0 ? (h2 % 2) - 1 : 1 - (h2 % 2)));
        if (int(h2) % 6 == 0) {
            rgb[1] = c; rgb[2] = x; rgb[3] = 0;
        } else if (int(h2) % 6 == 1) {
            rgb[1] = x; rgb[2] = c; rgb[3] = 0;
        } else if (int(h2) % 6 == 2) {
            rgb[1] = 0; rgb[2] = c; rgb[3] = x;
        } else if (int(h2) % 6 == 3) {
            rgb[1] = 0; rgb[2] = x; rgb[3] = c;
        } else if (int(h2) % 6 == 4) {
            rgb[1] = x; rgb[2] = 0; rgb[3] = c;
        } else if (int(h2) % 6 == 5) {
            rgb[1] = c; rgb[2] = 0; rgb[3] = x;
        }

        rgb[1] += hsv[2] - c;
        rgb[2] += hsv[2] - c;
        rgb[3] += hsv[2] - c;
    }

    BEGIN {
        srand();
        if (offset == "") offset = rand() * 360;
    }

    {
        y = NR - 1;
        for (x = 0; x < length($0); x++) {
            for (i = 0; i < 3; i++) {
                mult_x = cos((angle + i * angle_phase) / 57.2976);
                mult_y = sin((angle + i * angle_phase) / 57.2976);
                hsv[1] = (((x * mult_x + y * mult_y) / (width + width_phase * i)) % 1 + 1 + (offset + offset_phase * i) / 360) % 1;
                hsv[2] = 0.8;
                hsv[3] = 0.9;

                hsv_to_rgb(hsv, trgb);
                rgb[i + 1] = trgb[i + 1];
            }

            put_rgb(rgb);
            printf("%s", substr($0, x + 1, 1));
        }
        print "\033[0m";
    }
    '
}

# }}}
##############################################################################
# {{{ wfetch

# wfetch <URL> [--uri=URL-MIRROR] [--silent] [--sha256=SHA256] <--output-path=PATH>
# wfetch <URL> [--uri=URL-MIRROR] [--silent] [--sha256=SHA256] <--output-dir=DIR> <--output-name=NAME>
# wfetch <URL> [--uri=URL-MIRROR] [--silent] [--sha256=SHA256] <--output-dir=DIR> [--output-name=NAME]
# wfetch <URL> [--uri=URL-MIRROR] [--silent] [--sha256=SHA256] [--output-dir=DIR] <--output-name=NAME>

# influential environment variable:
# XCPKG_URL_TRANSFORM
wfetch() {
    unset FETCH_URL
    unset FETCH_URI
    unset FETCH_SHA256
    unset FETCH_OUTPUT_DIR
    unset FETCH_OUTPUT_NAME
    unset FETCH_OUTPUT_PATH
    unset FETCH_SILENT

    if [ -z "$1" ] ; then
        error "wfetch <URL> [OPTION]... , <URL> must be non-empty."
        return 1
    fi

    if [ -z "$XCPKG_URL_TRANSFORM" ] ; then
        FETCH_URL="$1"
    else
        FETCH_URL="$("$XCPKG_URL_TRANSFORM" "$1")" || return 1
    fi

    shift

    while [ -n "$1" ]
    do
        case $1 in
            --silent)
                FETCH_SILENT=yes
                RUN_SILENT=yes
                ;;
            --sha256=*)
                FETCH_SHA256=$(getvalue "$1")
                ;;
            --uri=*)
                FETCH_URI=$(getvalue "$1")
                if [ -z "$FETCH_URI" ] ; then
                    error "wfetch <URL> --uri=<URL-MIRROR> , <URL-MIRROR> must be non-empty."
                    return 1
                fi
                if [ -n "$XCPKG_URL_TRANSFORM" ] ; then
                    FETCH_URI="$("$XCPKG_URL_TRANSFORM" "$FETCH_URI")" || return 1
                fi
                ;;
            --output-dir=*)
                FETCH_OUTPUT_DIR=$(getvalue "$1")
                if [ -z "$FETCH_OUTPUT_DIR" ] ; then
                    error "wfetch <URL> --output-dir=<DIR> , <DIR> must be non-empty."
                    return 1
                fi
                ;;
            --output-name=*)
                FETCH_OUTPUT_NAME=$(getvalue "$1")
                if [ -z "$FETCH_OUTPUT_NAME" ] ; then
                    error "wfetch <URL> --output-name=<NAME> , <NAME> must be non-empty."
                    return 1
                fi
                ;;
            --output-path=*)
                FETCH_OUTPUT_PATH=$(getvalue "$1")
                if [ -z "$FETCH_OUTPUT_PATH" ] ; then
                    error "wfetch <URL> --output-path=<FILEPATH> , <FILEPATH> must be non-empty."
                    return 1
                fi
                ;;
            *)  error "wfetch <URL> [OPTION]..., unrecognized option: $1

    wfetch command usage:

    wfetch <URL> [--url-mirror=URL2] [--silent] [--sha256=SHA256] <--output-path=PATH>
    wfetch <URL> [--url-mirror=URL2] [--silent] [--sha256=SHA256] <--output-dir=DIR> <--output-name=NAME>
    wfetch <URL> [--url-mirror=URL2] [--silent] [--sha256=SHA256] <--output-dir=DIR> [--output-name=NAME]
    wfetch <URL> [--url-mirror=URL2] [--silent] [--sha256=SHA256] [--output-dir=DIR] <--output-name=NAME>"
                return 1
        esac
        shift
    done

    if [ -z "$FETCH_URI" ] ; then
        FETCH_URI="$FETCH_URL"
    fi

    if [ -z "$FETCH_OUTPUT_PATH" ] ; then
        if [ -z "$FETCH_OUTPUT_DIR" ] && [ -z "$FETCH_OUTPUT_NAME" ] ; then
            FETCH_OUTPUT_PATH='-'
        else
            if [ -z "$FETCH_OUTPUT_DIR" ] ; then
                FETCH_OUTPUT_DIR="$PWD"
            fi

            if [ -z "$FETCH_OUTPUT_NAME" ] ; then
                FETCH_OUTPUT_NAME=$(basename "$FETCH_URL")
            fi

            FETCH_OUTPUT_PATH="$FETCH_OUTPUT_DIR/$FETCH_OUTPUT_NAME"

            if [ !          -d "$FETCH_OUTPUT_DIR" ] ; then
                run install -d "$FETCH_OUTPUT_DIR" || return 1
            fi
        fi
    elif [ "$FETCH_OUTPUT_PATH" = '-' ] ; then
        unset FETCH_OUTPUT_DIR
        unset FETCH_OUTPUT_NAME
    else
        FETCH_OUTPUT_DIR="$(dirname $FETCH_OUTPUT_PATH)"
        FETCH_OUTPUT_NAME="$(basename $FETCH_OUTPUT_PATH)"
        if [ !          -d "$FETCH_OUTPUT_DIR" ] ; then
            run install -d "$FETCH_OUTPUT_DIR" || return 1
        fi
    fi

    case $FETCH_URL in
        *.git)
            if [    -d "$FETCH_OUTPUT_PATH" ] ; then
                run cd "$FETCH_OUTPUT_PATH" || return 1
                if      git rev-parse HEAD > /dev/null 2>&1 ; then
                    run git pull || return 1
                    run git submodule update --recursive || return 1
                else
                    run cd .. || return 1
                    run rm -rf "$FETCH_OUTPUT_NAME" || return 1
                    run git clone --recursive "$FETCH_URL" "$FETCH_OUTPUT_NAME" || return 1
                fi
            else
                if [ !          -d "$FETCH_OUTPUT_DIR" ] ; then
                    run install -d "$FETCH_OUTPUT_DIR" || return 1
                fi
                run cd "$FETCH_OUTPUT_DIR" || return 1
                run git clone --recursive "$FETCH_URL" "$FETCH_OUTPUT_NAME" || return 1
            fi
            ;;
        *)
            if [ "$FETCH_OUTPUT_PATH" != '-' ] && [ -f "$FETCH_OUTPUT_PATH" ] ; then
                if [ -n "$FETCH_SHA256" ] ; then
                    if [ "$(sha256sum "$FETCH_OUTPUT_PATH" | cut -d ' ' -f1)" = "$FETCH_SHA256" ] ; then
                        success "$FETCH_OUTPUT_PATH already have been fetched."
                        return 0
                    fi
                fi
                rm -f "$FETCH_OUTPUT_PATH" || return 1
            fi

            for FETCH_TOOL in curl wget http lynx aria2c axel
            do
                if command_exists_in_filesystem "$FETCH_TOOL" ; then
                    break
                else
                    unset FETCH_TOOL
                fi
            done

            if [ -z "$FETCH_TOOL" ] ; then
                error "no fetch tool found, please install one of curl|wget|http|lynx|aria2c|axel, then try again."
                return 1
            fi

            case $FETCH_TOOL in
                curl)
                    unset FETCH_TOOL_CURL_EXTRA_OPTIONS

                    if [ "$FETCH_SILENT" = yes ] ; then
                        FETCH_TOOL_CURL_OPTIONS='--no-progress-meter'
                    fi

                    if [ -f "$XCPKG_CORE_DIR/etc/ssl/certs/cacert.pem" ] ; then
                        FETCH_TOOL_CURL_OPTIONS="--cacert $XCPKG_CORE_DIR/etc/ssl/certs/cacert.pem"
                    fi

                    run "curl $FETCH_TOOL_CURL_OPTIONS --fail --retry 20 --retry-delay 30 --location -o '$FETCH_OUTPUT_PATH' '$FETCH_URL'" ||
                    run "curl $FETCH_TOOL_CURL_OPTIONS --fail --retry 20 --retry-delay 30 --location -o '$FETCH_OUTPUT_PATH' '$FETCH_URI'"
                    ;;
                wget)
                    run "wget --timeout=60 -O '$FETCH_OUTPUT_PATH' '$FETCH_URL'" ||
                    run "wget --timeout=60 -O '$FETCH_OUTPUT_PATH' '$FETCH_URI'"
                    ;;
                http)
                    run "http --timeout=60 -o '$FETCH_OUTPUT_PATH' '$FETCH_URL'" ||
                    run "http --timeout=60 -o '$FETCH_OUTPUT_PATH' '$FETCH_URI'"
                    ;;
                lynx)
                    run "lynx -source '$FETCH_URL' > '$FETCH_OUTPUT_PATH'" ||
                    run "lynx -source '$FETCH_URI' > '$FETCH_OUTPUT_PATH'"
                    ;;
                aria2c)
                    run "aria2c -d '$FETCH_OUTPUT_DIR' -o '$FETCH_OUTPUT_NAME' '$FETCH_URL'" ||
                    run "aria2c -d '$FETCH_OUTPUT_DIR' -o '$FETCH_OUTPUT_NAME' '$FETCH_URI'"
                    ;;
                axel)
                    run "axel -o '$FETCH_OUTPUT_PATH' '$FETCH_URL'" ||
                    run "axel -o '$FETCH_OUTPUT_PATH' '$FETCH_URI'"
                    ;;
                *)  error "wfetch() unimplementation: $FETCH_TOOL"
                    return 1
                    ;;
            esac

            [ $? -eq 0 ] || return 1

            if [ "$FETCH_OUTPUT_PATH" != '-' ] && [ -n "$FETCH_SHA256" ] ; then
                [ "$(sha256sum "$FETCH_OUTPUT_PATH" | cut -d ' ' -f1)" = "$FETCH_SHA256" ] || {
                    error "sha256sum mismatch.\n    expect : $FETCH_SHA256\n    actual : $(sha256sum $FETCH_OUTPUT_PATH | cut -d ' ' -f1)"
                    return 1
                }
            fi
    esac
}


# }}}
##############################################################################
# {{{ __upgrade_self

# __upgrade_self <URL>
  __upgrade_self() {
    if [ -z "$1" ] ; then
        error "__upgrade_self <URL> , <URL> must be non-empty."
        return 1
    fi

    unset CURRENT_SCRIPT_REALPATH

    # if file exists and is a symbolic link
    if [ -L "$CURRENT_SCRIPT_FILEPATH" ] ; then
        # https://unix.stackexchange.com/questions/136494/whats-the-difference-between-realpath-and-readlink-f#:~:text=GNU%20coreutils%20introduced%20a%20realpath,in%20common%20with%20GNU%20readlink%20.
        if command -v realpath > /dev/null ; then
            CURRENT_SCRIPT_REALPATH=$(realpath $CURRENT_SCRIPT_FILEPATH)
        elif command -v readlink > /dev/null && readlink -f xx > /dev/null 2>&1 ; then
            CURRENT_SCRIPT_REALPATH=$(readlink -f $CURRENT_SCRIPT_FILEPATH)
        else
            CURRENT_SCRIPT_REALPATH=$(realpath $CURRENT_SCRIPT_FILEPATH)
        fi
    else
        CURRENT_SCRIPT_REALPATH="$CURRENT_SCRIPT_FILEPATH"
    fi

    printf '%b\n' "$COLOR_PURPLE==>$COLOR_OFF ${COLOR_GREEN}mktemp -d$COLOR_OFF"
    WORKING_DIR=$(mktemp -d)

    run cd $WORKING_DIR

    wfetch "$1" --output-path="$WORKING_DIR/self"

    __upgrade_self_exit() {
        if [ -w "$CURRENT_SCRIPT_REALPATH" ] ; then
            run      install -m 755 self "$CURRENT_SCRIPT_REALPATH"
        else
            run sudo install -m 755 self "$CURRENT_SCRIPT_REALPATH"
        fi

        run rm -rf $WORKING_DIR
    }

    trap __upgrade_self_exit EXIT
}

# }}}
##############################################################################
# {{{ __integrate_zsh_completions

# __integrate_zsh_completions <URL> [--output-dir=<DIR>]
  __integrate_zsh_completions() {
    if [ -z "$1" ] ; then
        error "__integrate_zsh_completions <URL> [--output-dir=<DIR>] , <URL> must be non-empty."
        return 1
    else
        ZSH_COMPLETIONS_SCRIPT_URL="$1"
    fi

    shift

    unset OUTPUT_DIR

    for arg in $@
    do
        case $arg in
            --output-dir=*)
                OUTPUT_DIR=$(getvalue "$1")
                case $OUTPUT_DIR in
                    '')     die "__integrate_zsh_completions <URL> [--output-dir=<DIR>] , <DIR> must be non-empty." ;;
                    \~|\~/) OUTPUT_DIR="${HOME}" ;;
                    \~/*)   OUTPUT_DIR="$HOME/$(printf '%s\n' "$OUTPUT_DIR" | cut -c3-)" ;;
                esac
                ;;
            *)  die "__integrate_zsh_completions <URL> [--output-dir=<DIR>] , unrecognized argument: $arg"
        esac
    done

    ZSH_COMPLETIONS_SCRIPT_FILENAME="_$CURRENT_SCRIPT_FILENAME"

    if [ -n "$OUTPUT_DIR" ] ; then
        ZSH_COMPLETIONS_SCRIPT_OUT_FILEPATH="$OUTPUT_DIR/$ZSH_COMPLETIONS_SCRIPT_FILENAME"
    elif [ "$(uname)" = Linux ] && command -v termux-info > /dev/null && [ "$HOME" = '/data/data/com.termux/files/home' ] ; then
        ZSH_COMPLETIONS_SCRIPT_OUT_FILEPATH="/data/data/com.termux/files/usr/share/zsh/site-functions/$ZSH_COMPLETIONS_SCRIPT_FILENAME"
    else
        ZSH_COMPLETIONS_SCRIPT_OUT_FILEPATH="/usr/local/share/zsh/site-functions/$ZSH_COMPLETIONS_SCRIPT_FILENAME"
    fi

    # if file exists and is a symbolic link
    if [ -L "$ZSH_COMPLETIONS_SCRIPT_OUT_FILEPATH" ] ; then
        # https://unix.stackexchange.com/questions/136494/whats-the-difference-between-realpath-and-readlink-f#:~:text=GNU%20coreutils%20introduced%20a%20realpath,in%20common%20with%20GNU%20readlink%20.
        if command -v realpath > /dev/null ; then
            ZSH_COMPLETIONS_SCRIPT_OUT_FILEPATH=$(realpath $ZSH_COMPLETIONS_SCRIPT_OUT_FILEPATH)
        elif command -v readlink > /dev/null && readlink -f xx > /dev/null 2>&1 ; then
            ZSH_COMPLETIONS_SCRIPT_OUT_FILEPATH=$(readlink -f $ZSH_COMPLETIONS_SCRIPT_OUT_FILEPATH)
        else
            ZSH_COMPLETIONS_SCRIPT_OUT_FILEPATH=$(realpath $ZSH_COMPLETIONS_SCRIPT_OUT_FILEPATH)
        fi
    fi

    printf '%b\n' "$COLOR_PURPLE==>$COLOR_OFF ${COLOR_GREEN}mktemp -d$COLOR_OFF"
    WORKING_DIR=$(mktemp -d)

    run cd $WORKING_DIR

    wfetch "$ZSH_COMPLETIONS_SCRIPT_URL" --output-path="$WORKING_DIR/$ZSH_COMPLETIONS_SCRIPT_FILENAME"

    if [ -f "$ZSH_COMPLETIONS_SCRIPT_OUT_FILEPATH" ] ; then
        if [ -w "$ZSH_COMPLETIONS_SCRIPT_OUT_FILEPATH" ] ; then
            run      install -m 644 "$ZSH_COMPLETIONS_SCRIPT_FILENAME" "$ZSH_COMPLETIONS_SCRIPT_OUT_FILEPATH"
        else
            run sudo install -m 644 "$ZSH_COMPLETIONS_SCRIPT_FILENAME" "$ZSH_COMPLETIONS_SCRIPT_OUT_FILEPATH"
        fi
    else
        ZSH_COMPLETIONS_SCRIPT_OUT_DIR="$(dirname "$ZSH_COMPLETIONS_SCRIPT_OUT_FILEPATH")"
        if [ ! -d "$ZSH_COMPLETIONS_SCRIPT_OUT_DIR" ] ; then
            run install -d "$ZSH_COMPLETIONS_SCRIPT_OUT_DIR" || run sudo install -d "$ZSH_COMPLETIONS_SCRIPT_OUT_DIR"
        fi
        if [ -w "$ZSH_COMPLETIONS_SCRIPT_OUT_DIR" ] ; then
            run      install -m 644 "$ZSH_COMPLETIONS_SCRIPT_FILENAME" "$ZSH_COMPLETIONS_SCRIPT_OUT_FILEPATH"
        else
            run sudo install -m 644 "$ZSH_COMPLETIONS_SCRIPT_FILENAME" "$ZSH_COMPLETIONS_SCRIPT_OUT_FILEPATH"
        fi
    fi

    run rm -rf $WORKING_DIR

    printf '\n'
    note "${COLOR_YELLOW}you need to run command${COLOR_RED} ${COLOR_GREEN}autoload -U compinit && compinit${COLOR_OFF} ${COLOR_YELLOW}in zsh to make it work.${COLOR_OFF}"
}

# }}}
##############################################################################
# {{{ version

version_of_python_module() {
    unset PIP_COMMAND
    PIP_COMMAND=$(command -v pip3 || command -v pip)
    if [ -z "$PIP_COMMAND" ] ; then
        die "can't found pip command."
    else
        "$PIP_COMMAND" show $1 | grep 'Version:' | cut -d ' ' -f2
    fi
}

# retrive the version of a command from it's name or path
version_of_command() {
    case $(basename "$1") in
       ccache) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f3 ;;
        xmake) "$1" --version 2> /dev/null | head -n 1 | cut -d '+' -f1 | cut -d 'v' -f2 ;;
        cmake) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f3 ;;
         rake) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f3 ;;
         make) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f3 ;;
        gmake) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f3 ;;
       rustup) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f2 ;;
       rustc)  "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f2 ;;
        cargo) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f2 ;;
           go) "$1"   version | cut -d ' ' -f3 | cut -c3- ;;
         tree) "$1" --version | cut -d ' ' -f2 | cut -c2- ;;
   pkg-config) "$1" --version 2> /dev/null | head -n 1 ;;
     patchelf) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f2 ;;
       m4|gm4) "$1" --version 2> /dev/null | head -n 1 | awk '{print($NF)}';;
    autopoint) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f4 ;;
     xgettext) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f4 ;;
     automake|aclocal)
               "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f4 ;;
     autoconf|autoheader|autom4te|autoreconf|autoscan|autoupdate|ifnames)
               "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f4 ;;
     realpath) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f4 ;;
      libtool) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f4 ;;
   libtoolize|glibtoolize)
               "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f4 ;;
  intltoolize) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f4 ;;
      objcopy) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f5 ;;
         flex) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f2 ;;
        bison) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f4 ;;
         yacc) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f4 ;;
         nasm) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f3 ;;
         yasm) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f2 ;;
        patch) "$1" --version 2> /dev/null | head -n 1 | awk '{print($NF)}' ;;
        gperf) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f3 ;;
        groff) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f4 ;;
     makeinfo) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f4 ;;
     help2man) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f3 ;;
    gtkdocize) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f3 ;;
 sphinx-build) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f2 ;;
 glib-mkenums) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f3 ;;
 glib-compile-resources)
               "$1" --version ;;
         file) "$1" --version 2> /dev/null | head -n 1 | cut -d '-' -f2 ;;
      itstool) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f2 ;;
       protoc) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f2 ;;
        xmlto) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f3 ;;
      xmllint) ;;
     xsltproc) ;;
     rst2man|rst2man.py|rst2man-3|rst2man-3.6|rst2man-3.7|rst2man-3.8|rst2man-3.9)
               "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f3 ;;
         java) "$1"  -version 2>&1 | head -n 1 | cut -d ' ' -f3 | sed 's/"//g' ;;
         gzip) "$1" --version 2>&1 | head -n 1 | awk '{print($NF)}' ;;
         lzip) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f2 ;;
           xz) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f4 ;;
          zip) "$1" --version 2> /dev/null | sed -n '2p' | cut -d ' ' -f4 ;;
        unzip) "$1" -v        2> /dev/null | head -n 1 | cut -d ' ' -f2 ;;
        bzip2) "$1" --help 2>&1 | head -n 1 | cut -d ' ' -f8 | cut -d ',' -f1 ;;
          tar)
            VERSION_MSG=$("$1" --version 2> /dev/null | head -n 1)
            case $VERSION_MSG in
                  tar*) echo "$VERSION_MSG" | cut -d ' ' -f4 ;;
               bsdtar*) echo "$VERSION_MSG" | cut -d ' ' -f2 ;;
            esac
            ;;
          git) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f3 ;;
         curl) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f2 ;;
     awk|gawk) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f3 | tr , ' ' ;;
     sed|gsed) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f4 ;;
         cpan) ;;
         find) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f4 ;;
         diff) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f4 ;;
         grep) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f4 | cut -d '-' -f1 ;;
         ruby) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f2 ;;
         perl) "$1" -v | sed -n '2p' | sed 's/.*v\([0-9]\.[0-9][0-9]\.[0-9]\).*/\1/' ;;
          lua) "$1" -v 2>/dev/null | head -n 1 | cut -d ' ' -f2 ;;
    python|python2|python3)
               "$1" --version 2>&1 | head -n 1 | cut -d ' ' -f2 ;;
         pip)  "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f2 ;;
         pip3) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f2 ;;
         node) "$1" --version 2> /dev/null | head -n 1 | cut -d 'v' -f2 ;;
          zsh) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f2 ;;
         bash) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f4 | cut -d '(' -f1 ;;
       base64) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f4 ;;
      hexdump) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f4 ;;
      sqlite3) "$1"  -version 2> /dev/null | head -n 1 | cut -d ' ' -f1 ;;
            *) "$1" --version 2> /dev/null | head -n 1
    esac
}

# retrive the major part of the version of the given command
# Note: the version of the given command must have form: major.minor.patch
version_major_of_command() {
    version_of_command "$1" | cut -d. -f1
}

# retrive the minor part of the version of the given command
# Note: the version of the given command must have form: major.minor.patch
version_minor_of_command() {
    version_of_command "$1" | cut -d. -f2
}

# retrive the major part of the given version
# Note: the given version must have form: major.minor.patch
version_major_of_version() {
    echo "$1" | cut -d. -f1
}

# retrive the minor part of the given version
# Note: the given version must have form: major.minor.patch
version_minor_of_version() {
    echo "$1" | cut -d. -f2
}

version_sort() {
    # https://pubs.opengroup.org/onlinepubs/9699919799/utilities/sort.html
    # https://man.netbsd.org/NetBSD-8.1/i386/sort.1
    #
    # sort: unrecognized option: V
    # BusyBox v1.29.3 (2019-01-24 07:45:07 UTC) multi-call binary.
    # Usage: sort [-nrugMcszbdfiokt] [-o FILE] [-k start[.offset][opts][,end[.offset][opts]] [-t CHAR] [FILE]...
    if  echo | (sort -V > /dev/null 2>&1) ; then
        echo "$@" | tr ' ' '\n' | sort -V
    else
        echo "$@" | tr ' ' '\n' | sort -t. -n -k1,1 -k2,2 -k3,3 -k4,4
    fi
}

# check if match the condition
#
# condition:
# eq  equal
# ne  not equal
# gt  greater than
# lt  less than
# ge  greater than or equal
# le  less than or equal
#
# examples:
# version_match 1.15.3 eq 1.16.0
# version_match 1.15.3 lt 1.16.0
# version_match 1.15.3 gt 1.16.0
# version_match 1.15.3 le 1.16.0
# version_match 1.15.3 ge 1.16.0
version_match() {
    case $2 in
        eq)  [ "$1"  = "$3" ] ;;
        ne)  [ "$1" != "$3" ] ;;
        le)
            if [ "$1" = "$3" ] ; then
                return 0
            fi
            [ "$1" = "$(version_sort "$1" "$3" | head -n 1)" ]
            ;;
        ge)
            if [ "$1" = "$3" ] ; then
                return 0
            fi
            [ "$1" = "$(version_sort "$1" "$3" | tail -n 1)" ]
            ;;
        lt)
            if [ "$1" = "$3" ] ; then
                return 1
            fi
            [ "$1" = "$(version_sort "$1" "$3" | head -n 1)" ]
            ;;
        gt)
            if [ "$1" = "$3" ] ; then
                return 1
            fi
            [ "$1" = "$(version_sort "$1" "$3" | tail -n 1)" ]
            ;;
        *)  die "version_compare: $2: not supported operator."
    esac
}

# check if the version of give installed command match the condition
#
# condition:
# eq  equal
# ne  not equal
# gt  greater than
# lt  less than
# ge  greater than or equal
# le  less than or equal
#
# examples:
# command_exists_in_filesystem_and_version_matched automake eq 1.16.0
# command_exists_in_filesystem_and_version_matched automake lt 1.16.0
# command_exists_in_filesystem_and_version_matched automake gt 1.16.0
# command_exists_in_filesystem_and_version_matched automake le 1.16.0
# command_exists_in_filesystem_and_version_matched automake ge 1.16.0
# command_exists_in_filesystem_and_version_matched automake
command_exists_in_filesystem_and_version_matched() {
    if command_exists_in_filesystem "$1" ; then
        if [ $# -eq 3 ] ; then
            version_match "$(version_of_command "$1")" "$2" "$3"
        fi
    else
        return 1
    fi
}

get_file_extension_from_url() {
    unset URL
    URL="$(printf '%s\n' "$1" | sed 's|\?.*||')"

    unset EXT
    EXT="$(printf '%s\n' "$URL" | sed 's|.*\(\.[^.]\+$\)|\1|g')"

    case $EXT in
        .gz)  printf '%s\n' '.tgz' ;;
        .lz)  printf '%s\n' '.tlz' ;;
        .xz)  printf '%s\n' '.txz' ;;
        .bz2) printf '%s\n' '.tbz2' ;;
        *)    printf '%s\n' "$EXT" ;;
    esac
}

# }}}
##############################################################################
# {{{ operations of formula

__load_formula_of_the_given_package() {
    unset PACKAGE_FORMULA_LOADED

    unset PACKAGE_NAME
    unset PACKAGE_NAME_UPPERCASE_UNDERSCORE

    unset PACKAGE_SUMMARY
    unset PACKAGE_WEB_URL

    unset PACKAGE_GIT_URL
    unset PACKAGE_GIT_SHA
    unset PACKAGE_GIT_REF
    unset PACKAGE_SHALLOW

    unset PACKAGE_SVN_URL

    unset PACKAGE_SRC_URL
    unset PACKAGE_SRC_URI
    unset PACKAGE_SRC_SHA
    unset PACKAGE_SRC_FILENAME
    unset PACKAGE_SRC_FILETYPE
    unset PACKAGE_SRC_FILEPATH

    unset PACKAGE_FIX_URL
    unset PACKAGE_FIX_SHA
    unset PACKAGE_FIX_FILENAME
    unset PACKAGE_FIX_FILETYPE
    unset PACKAGE_FIX_FILEPATH

    unset PACKAGE_RES_URL
    unset PACKAGE_RES_SHA
    unset PACKAGE_RES_FILENAME
    unset PACKAGE_RES_FILETYPE
    unset PACKAGE_RES_FILEPATH

    unset PACKAGE_VERSION
    unset PACKAGE_VERSION_MAJOR
    unset PACKAGE_VERSION_MINOR
    unset PACKAGE_VERSION_PATCH
    unset PACKAGE_VERSION_TWEAK

    unset PACKAGE_DEVELOPER

    unset PACKAGE_LICENSE

    unset PACKAGE_BSYSTEM

    unset PACKAGE_SYMLINK

    unset PACKAGE_BUILD_SYSTEM
    unset PACKAGE_BUILD_SYSTEM_GO
    unset PACKAGE_BUILD_SYSTEM_RAKE
    unset PACKAGE_BUILD_SYSTEM_NINJA
    unset PACKAGE_BUILD_SYSTEM_GMAKE
    unset PACKAGE_BUILD_SYSTEM_CMAKE
    unset PACKAGE_BUILD_SYSTEM_XMAKE
    unset PACKAGE_BUILD_SYSTEM_MESON
    unset PACKAGE_BUILD_SYSTEM_CARGO
    unset PACKAGE_BUILD_SYSTEM_AUTOGENSH
    unset PACKAGE_BUILD_SYSTEM_AUTOTOOLS
    unset PACKAGE_BUILD_SYSTEM_CONFIGURE
    unset PACKAGE_BUILD_SYSTEM_NDK_BUILD

    # dir relative to $PACKAGE_WORKING_DIR, which contains build script such as autogen.sh, configure, Makefile, CMakeLists.txt, meson.build, Cargo.toml, xmake.lua, etc.
    unset PACKAGE_BSCRIPT

    # if build in build script dir, otherwise build in build dir
    unset PACKAGE_BINBSTD
    unset PACKAGE_BUILD_IN_BSCRIPT_DIR

    # if build in parallel
    unset PACKAGE_BUILD_IN_PARALLEL
    unset PACKAGE_PARALLEL

    # space-separated    perl modules that are depended by this package when installing and/or runtime, which will be installed via cpan
    unset PACKAGE_DEP_PLM

    # space-separated python packages that are depended by this package when installing and/or runtime, which will be installed via pip3
    unset PACKAGE_DEP_PYM

    # space-separated   xcpkg packages that are depended by this package when installing and/or runtime, which will be installed via uppm
    unset PACKAGE_DEP_UPP

    # space-separated   xcpkg packages that are depended by this package when installing and/or runtime, which will be installed via xcpkg
    unset PACKAGE_DEP_PKG

    unset PACKAGE_CDEFINE
    unset PACKAGE_CCFLAGS
    unset PACKAGE_XXFLAGS
    unset PACKAGE_LDFLAGS

    unset PACKAGE_FORMULA_FILEPATH

    unset -f prepare
    unset -f build
    unset -f build_configed

    PACKAGE_FORMULA_FILEPATH="$(__path_of_formula_of_the_given_package $1)" || return 1

    for key in summary web-url git-url git-sha git-ref shallow src-url src-uri src-sha fix-url fix-sha res-url res-sha dep-pkg dep-upp dep-pym dep-plm license version bsystem bscript binbstd cdefine ccflags xxflags ldflags parallel toolset cstdlib exetype symlink
    do
        unset __KEY_UPPERCASE_UNDERSCORE__
        unset __VALUE__

        __KEY_UPPERCASE_UNDERSCORE__="$(printf '%s\n' "$key" | tr '-' '_' | tr a-z A-Z)"
        __VALUE__="$(yq ".$key" "$PACKAGE_FORMULA_FILEPATH")"

        if [ "$__VALUE__" = null ] ; then
               __VALUE__=
        fi

        eval "PACKAGE_$__KEY_UPPERCASE_UNDERSCORE__='$__VALUE__'"
    done

    unset PACKAGE_PREPARE_ACTIONS
    PACKAGE_PREPARE_ACTIONS="$(yq .prepare "$PACKAGE_FORMULA_FILEPATH")"

    unset PACKAGE_INSTALL_ACTIONS
    PACKAGE_INSTALL_ACTIONS="$(yq .install "$PACKAGE_FORMULA_FILEPATH")"

    [ "$PACKAGE_PREPARE_ACTIONS" = null ] && unset PACKAGE_PREPARE_ACTIONS
    [ "$PACKAGE_INSTALL_ACTIONS" = null ] && unset PACKAGE_INSTALL_ACTIONS

    if [ -z "$PACKAGE_BSYSTEM" ] && [ -n "$PACKAGE_INSTALL_ACTIONS" ]; then
        for FirstWordOfLineInInstallActions in $(printf '%s\n' "$PACKAGE_INSTALL_ACTIONS" | sed 's|^[ ]*||' | cut -d ' ' -f1)
        do
            case "$FirstWordOfLineInInstallActions" in
                configure)    PACKAGE_BSYSTEM=configure ; break ;;
                cmakew)       PACKAGE_BSYSTEM=cmake ; break ;;
                xmakew)       PACKAGE_BSYSTEM=xmake ; break ;;
                mesonw)       PACKAGE_BSYSTEM=meson ; break ;;
                gmakew)       PACKAGE_BSYSTEM=gmake ; break ;;
                cargow)       PACKAGE_BSYSTEM=cargo ; break ;;
                go|gow)       PACKAGE_BSYSTEM=go    ; break ;;
            esac
        done
    fi

    PACKAGE_NAME="$1"
    PACKAGE_NAME_UPPERCASE_UNDERSCORE=$(printf '%s\n' "$PACKAGE_NAME" | tr a-z A-Z | tr '@+-.' '_')

    PACKAGE_BUILD_SYSTEM=$PACKAGE_BSYSTEM

    PACKAGE_BUILD_IN_BSCRIPT_DIR=$PACKAGE_BINBSTD

    if [ -z "$PACKAGE_SYMLINK" ] ; then
        PACKAGE_SYMLINK=yes
    fi

    if [ -z "$PACKAGE_PARALLEL" ] ; then
        PACKAGE_PARALLEL=yes
        PACKAGE_BUILD_IN_PARALLEL=yes
    else
        PACKAGE_BUILD_IN_PARALLEL="$PACKAGE_PARALLEL"
    fi

    if [ -z "$PACKAGE_SUMMARY" ] ; then
        die "summary mapping not found in $PACKAGE_FORMULA_FILEPATH"
    fi

    if [ -z "$PACKAGE_WEB_URL" ] && [ -z "$PACKAGE_GIT_URL" ] ; then
        die "web-url or git-url mapping not found in $PACKAGE_FORMULA_FILEPATH"
    fi

    if [ -z "$PACKAGE_SRC_URL" ] ; then
        if [ -z "$PACKAGE_GIT_URL" ] ; then
            die "src-url or git-url mapping not found in $PACKAGE_FORMULA_FILEPATH"
        else
            PACKAGE_SRC_FILETYPE=.git
            PACKAGE_DEP_UPP="$PACKAGE_DEP_UPP git"
        fi
    else
        case $PACKAGE_SRC_URL in
            dir://*)
                PACKAGE_SRC_FILETYPE=.dir ;;
            *)  PACKAGE_SRC_FILETYPE="$(get_file_extension_from_url "$PACKAGE_SRC_URL")"

                case $PACKAGE_SRC_FILETYPE in
                    .zip)     PACKAGE_DEP_UPP="$PACKAGE_DEP_UPP curl unzip"      ;;
                    .txz)     PACKAGE_DEP_UPP="$PACKAGE_DEP_UPP curl gtar xz"    ;;
                    .tgz)     PACKAGE_DEP_UPP="$PACKAGE_DEP_UPP curl gtar gzip"  ;;
                    .tlz)     PACKAGE_DEP_UPP="$PACKAGE_DEP_UPP curl gtar lzip"  ;;
                    .tbz2)    PACKAGE_DEP_UPP="$PACKAGE_DEP_UPP curl gtar bzip2" ;;
                    *)        PACKAGE_DEP_UPP="$PACKAGE_DEP_UPP curl"            ;;
                esac
        esac
    fi

    case $PACKAGE_SRC_FILETYPE in
        .dir)
            PACKAGE_SRC_FILEPATH=$(printf '%s\n' "$PACKAGE_SRC_URL" | cut -c7-)

            if [ -z "$PACKAGE_VERSION" ] ; then
                PACKAGE_VERSION="$(format_unix_timestamp "$TIMESTAMP_UNIX" '+%Y.%m.%d')"
            fi
            ;;
        .git)
            PACKAGE_SRC_FILENAME="$PACKAGE_NAME.git"
            PACKAGE_SRC_FILEPATH="$XCPKG_DOWNLOADS_DIR/$PACKAGE_SRC_FILENAME"

            if [ -z "$PACKAGE_VERSION" ] ; then
                PACKAGE_VERSION="$(format_unix_timestamp "$TIMESTAMP_UNIX" '+%Y.%m.%d')"
            fi
            ;;
        *)
            if [ -z "$PACKAGE_SRC_SHA" ] ; then
                die "src-sha mapping not found in $PACKAGE_FORMULA_FILEPATH"
            fi

            if [ -z "$PACKAGE_VERSION" ] ; then
                PACKAGE_VERSION="$(basename "$PACKAGE_SRC_URL" | tr '_@' - | sed -e 's|\.tar\.[glx]z$||' -e 's|\.tar\.bz2$||' -e 's|\.t[glx]z$||' -e 's|\.zip$||' -e 's|-stable||' -e 's|-source||' -e 's|[-.]src$||' -e 's|\.orig||' | awk -F- '{print $NF}')"
                case $PACKAGE_VERSION in
                    '') die "version mapping not found in $PACKAGE_FORMULA_FILEPATH" ;;
                    v*) PACKAGE_VERSION=$(printf '%s\n' "$PACKAGE_VERSION" | cut -c2-)
                esac
            fi

            PACKAGE_SRC_FILENAME="$PACKAGE_SRC_SHA$PACKAGE_SRC_FILETYPE"
            PACKAGE_SRC_FILEPATH="$XCPKG_DOWNLOADS_DIR/$PACKAGE_SRC_FILENAME"
    esac

    if [ -n "$PACKAGE_FIX_URL" ] ; then
        if [ -z "$PACKAGE_FIX_SHA" ] ; then
            die "fix-sha mapping not found in $PACKAGE_FORMULA_FILEPATH"
        fi

        PACKAGE_FIX_FILETYPE="$(get_file_extension_from_url "$PACKAGE_FIX_URL")"

        case $PACKAGE_FIX_FILETYPE in
            .diff)  PACKAGE_DEP_UPP="$PACKAGE_DEP_UPP patch"            ;;
            .patch) PACKAGE_DEP_UPP="$PACKAGE_DEP_UPP patch"            ;;
            .zip)   PACKAGE_DEP_UPP="$PACKAGE_DEP_UPP patch unzip"      ;;
            .txz)   PACKAGE_DEP_UPP="$PACKAGE_DEP_UPP patch gtar xz"    ;;
            .tgz)   PACKAGE_DEP_UPP="$PACKAGE_DEP_UPP patch gtar gzip"  ;;
            .tlz)   PACKAGE_DEP_UPP="$PACKAGE_DEP_UPP patch gtar lzip"  ;;
            .tbz2)  PACKAGE_DEP_UPP="$PACKAGE_DEP_UPP patch gtar bzip2" ;;
        esac

        PACKAGE_FIX_FILENAME="$PACKAGE_FIX_URL$PACKAGE_FIX_FILETYPE"
        PACKAGE_FIX_FILEPATH="$XCPKG_DOWNLOADS_DIR/$PACKAGE_FIX_FILENAME"
    fi

    if [ -n "$PACKAGE_RES_URL" ] ; then
        if [ -z "$PACKAGE_RES_SHA" ] ; then
            die "res-sha mapping not found in $PACKAGE_FORMULA_FILEPATH"
        fi

        PACKAGE_RES_FILETYPE="$(get_file_extension_from_url "$PACKAGE_RES_URL")"

        case $PACKAGE_RES_FILETYPE in
            .diff)  PACKAGE_DEP_UPP="$PACKAGE_DEP_UPP patch"            ;;
            .patch) PACKAGE_DEP_UPP="$PACKAGE_DEP_UPP patch"            ;;
            .zip)   PACKAGE_DEP_UPP="$PACKAGE_DEP_UPP patch unzip"      ;;
            .txz)   PACKAGE_DEP_UPP="$PACKAGE_DEP_UPP patch gtar xz"    ;;
            .tgz)   PACKAGE_DEP_UPP="$PACKAGE_DEP_UPP patch gtar gzip"  ;;
            .tlz)   PACKAGE_DEP_UPP="$PACKAGE_DEP_UPP patch gtar lzip"  ;;
            .tbz2)  PACKAGE_DEP_UPP="$PACKAGE_DEP_UPP patch gtar bzip2" ;;
        esac

        PACKAGE_RES_FILENAME="$PACKAGE_RES_URL$PACKAGE_RES_FILETYPE"
        PACKAGE_RES_FILEPATH="$XCPKG_DOWNLOADS_DIR/$PACKAGE_RES_FILENAME"
    fi

    if [ -n "$PACKAGE_VERSION" ] ; then
        PACKAGE_VERSION_MAJOR="$(printf '%s\n' "$PACKAGE_VERSION" | cut -d. -f1)"
        PACKAGE_VERSION_MINOR="$(printf '%s\n' "$PACKAGE_VERSION" | cut -d. -f2)"
        PACKAGE_VERSION_PATCH="$(printf '%s\n' "$PACKAGE_VERSION" | cut -d. -f3)"
        PACKAGE_VERSION_TWEAK="$(printf '%s\n' "$PACKAGE_VERSION" | cut -d. -f4)"
    fi

    for item in $PACKAGE_BUILD_SYSTEM
    do
        case $item in
            autogen)     PACKAGE_BUILD_SYSTEM_AUTOGENSH=yes ; PACKAGE_BUILD_SYSTEM_GMAKE=yes ;;
            autotools)   PACKAGE_BUILD_SYSTEM_AUTOTOOLS=yes ; PACKAGE_BUILD_SYSTEM_GMAKE=yes ;;
            configure)   PACKAGE_BUILD_SYSTEM_CONFIGURE=yes ; PACKAGE_BUILD_SYSTEM_GMAKE=yes ;;
            cmake-gmake) PACKAGE_BUILD_SYSTEM_CMAKE=yes     ; PACKAGE_BUILD_SYSTEM_GMAKE=yes ;;
            cmake-ninja) PACKAGE_BUILD_SYSTEM_CMAKE=yes     ; PACKAGE_BUILD_SYSTEM_NINJA=yes ;;
            cmake)       PACKAGE_BUILD_SYSTEM_CMAKE=yes     ; PACKAGE_BUILD_SYSTEM_NINJA=yes ;;
            xmake)       PACKAGE_BUILD_SYSTEM_XMAKE=yes     ;;
            meson)       PACKAGE_BUILD_SYSTEM_MESON=yes     ; PACKAGE_BUILD_SYSTEM_NINJA=yes ;;
            ninja)       PACKAGE_BUILD_SYSTEM_NINJA=yes     ;;
            gmake)       PACKAGE_BUILD_SYSTEM_GMAKE=yes     ;;
            rake)        PACKAGE_BUILD_SYSTEM_RAKE=yes      ;;
            cargo)       PACKAGE_BUILD_SYSTEM_CARGO=yes     ;;
            go)          PACKAGE_BUILD_SYSTEM_GO=yes        ;;
        esac
    done

    for item in $PACKAGE_BUILD_SYSTEM
    do
        case $item in
            autogen)     PACKAGE_DEP_UPP="$PACKAGE_DEP_UPP automake autoconf gm4 gmake" ;;
            autotools)   PACKAGE_DEP_UPP="$PACKAGE_DEP_UPP automake autoconf gm4 gmake" ;;
            configure)   PACKAGE_DEP_UPP="$PACKAGE_DEP_UPP gmake"  ;;
            cmake-gmake) PACKAGE_DEP_UPP="$PACKAGE_DEP_UPP cmake gmake"  ;;
            cmake-ninja) PACKAGE_DEP_UPP="$PACKAGE_DEP_UPP cmake ninja"  ;;
            cmake)       PACKAGE_DEP_UPP="$PACKAGE_DEP_UPP cmake ninja"  ;;
            xmake)       PACKAGE_DEP_UPP="$PACKAGE_DEP_UPP xmake"  ;;
            meson)       PACKAGE_DEP_UPP="$PACKAGE_DEP_UPP ninja"  ;;
            ninja)       PACKAGE_DEP_UPP="$PACKAGE_DEP_UPP ninja"  ;;
            gmake)       PACKAGE_DEP_UPP="$PACKAGE_DEP_UPP gmake"  ;;
            rake)        PACKAGE_DEP_UPP="$PACKAGE_DEP_UPP ruby"   ;;
            go)          PACKAGE_DEP_UPP="$PACKAGE_DEP_UPP golang" ;;
        esac
    done

    if [ "$PACKAGE_BUILD_SYSTEM_MESON" = yes ] ; then
        PACKAGE_DEP_PYM="$PACKAGE_DEP_PYM meson"
    fi

    if [ -n "$PACKAGE_DEP_PYM" ] ; then
        PACKAGE_DEP_PKG="$PACKAGE_DEP_UPP python3"
    fi

    if [ -n "$PACKAGE_DEP_PLM" ] ; then
        PACKAGE_DEP_PKG="$PACKAGE_DEP_UPP perl"
    fi

    if [ "$PACKAGE_BUILD_IN_PARALLEL" = no ] ; then
        BUILD_NJOBS=1
    fi

    if [ "$PACKAGE_BUILD_SYSTEM_GO" = yes ] ; then
        PACKAGE_BINBSTD=yes
        PACKAGE_BUILD_IN_BSCRIPT_DIR=yes
    fi

    if [ "$PACKAGE_BUILD_SYSTEM_CARGO" = yes ] ; then
        PACKAGE_BINBSTD=yes
        PACKAGE_BUILD_IN_BSCRIPT_DIR=yes
    fi

    if [ "$PACKAGE_BUILD_SYSTEM_XMAKE" = yes ] ; then
        PACKAGE_BINBSTD=yes
        PACKAGE_BUILD_IN_BSCRIPT_DIR=yes
    fi

    PACKAGE_FORMULA_LOADED=yes
}

# examples:
# __view_formula_of_the_given_package curl
# __view_formula_of_the_given_package curl --paging=never
  __view_formula_of_the_given_package() {
    [ -z "$1" ] && {
        error "__view_formula_of_the_given_package <PACKAGE-NAME>, <PACKAGE-NAME> is unspecified."
        return 1
    }

    unset PACKAGE_FORMULA_FILEPATH
    PACKAGE_FORMULA_FILEPATH="$(__path_of_formula_of_the_given_package $1)" || return 1

    shift

    unset VIEW_FORMULA_PAGING

    while [ -n "$1" ]
    do
        case $1 in
            --paging=*)
                VIEW_FORMULA_PAGING=$(getvalue "$1")
                case $VIEW_FORMULA_PAGING in
                    auto|always|never) ;;
                    *) die "--paging=<VALUE>, <VALUE> must be one of auto|always|never"
                esac
                ;;
            *)  die "unrecognized argument: $1"
        esac
        shift
    done

    case $VIEW_FORMULA_PAGING in
        ''|auto)
            if command -v bat > /dev/null ; then
                bat --language=yaml --paging=auto "$PACKAGE_FORMULA_FILEPATH"
            else
                cat "$PACKAGE_FORMULA_FILEPATH"
                echo
                prompt_user_to_install_bat
            fi
            ;;
        always)
            if command -v bat > /dev/null ; then
                bat --language=yaml --paging=always "$PACKAGE_FORMULA_FILEPATH"
            else
                more "$PACKAGE_FORMULA_FILEPATH"
                echo
                prompt_user_to_install_bat
            fi
            ;;
        never)
            if command -v bat > /dev/null ; then
                bat --language=yaml --paging=never "$PACKAGE_FORMULA_FILEPATH"
            else
                cat "$PACKAGE_FORMULA_FILEPATH"
                echo
                prompt_user_to_install_bat
            fi
            ;;
    esac
}

# __edit_formula_of_the_given_package <PACKAGE-NAME>
  __edit_formula_of_the_given_package() {
    [ -z "$1" ] && {
        error "__edit_formula_of_the_given_package <PACKAGE-NAME>, <PACKAGE-NAME> is unspecified."
        return 1
    }

    unset PACKAGE_FORMULA_FILEPATH
    PACKAGE_FORMULA_FILEPATH="$(__path_of_formula_of_the_given_package $1)" || return 1

    [ -z "$2" ] || warn "edit action accept only one argument."

    if [ -z "$EDITOR" ] ; then
        EDITOR=$(command -v nvim || command -v vim || command -v vi || command -v open) || die "please set EDITOR environment variable."
    fi

    "$EDITOR" "$PACKAGE_FORMULA_FILEPATH"
}

# __create_formula_of_the_given_package <PACKAGE-NAME>
  __create_formula_of_the_given_package() {
    [ -z "$1" ] && {
        error "__create_formula_of_the_given_package <PACKAGE-NAME>, <PACKAGE-NAME> is unspecified."
        return 1
    }

    unset REPO_NAME
    REPO_NAME=offical-core

    if [ -e "$XCPKG_FORMULA_REPO_DIR/$REPO_NAME/formula/$1.yml" ] ; then
        die "$XCPKG_FORMULA_REPO_DIR/$REPO_NAME/formula/$1.yml formula already exists."
    fi

    cat > "$XCPKG_FORMULA_REPO_DIR/$REPO_NAME/formula/$1.yml" <<EOF
summary: Summary of this package
web-url: https://www.xx.com
src-url: https://www.xx.com/pkgname-x.y.z.tar.gz
src-sha: c3e5e9fdd5004dcb542feda5ee4f0ff0744628baf8ed2dd5d66f8ca1197cb1a1
version: x.y.z
dep-pkg: a b c
prepare:
install:
EOF
    __edit_formula_of_the_given_package "$1"
}

# __delete_formula_of_the_given_package <PACKAGE-NAME>
  __delete_formula_of_the_given_package() {
    [ -z "$1" ] && {
        error "__delete_formula_of_the_given_package <PACKAGE-NAME>, <PACKAGE-NAME> is unspecified."
        return 1
    }

    unset PACKAGE_FORMULA_FILEPATH
    PACKAGE_FORMULA_FILEPATH="$(__path_of_formula_of_the_given_package $1)" || return 1

    run rm "$PACKAGE_FORMULA_FILEPATH"
}

# __rename_formula_of_the_given_package <OLD-PACKAGE-NAME> <NEW-PACKAGE-NAME>
__rename_formula_of_the_given_package() {
    [ -z "$1" ] && {
        error "__rename_formula_of_the_given_package <OLD-PACKAGE-NAME> <NEW-PACKAGE-NAME>, <OLD-PACKAGE-NAME> is unspecified."
        return 1
    }

    [ -z "$2" ] && {
        error "__rename_formula_of_the_given_package <OLD-PACKAGE-NAME> <NEW-PACKAGE-NAME>, <NEW-PACKAGE-NAME> is unspecified."
        return 1
    }

    unset PACKAGE_FORMULA_REPO
    PACKAGE_FORMULA_REPO="$(__repo_of_formula_of_the_given_package $1)" || return 1

    unset PACKAGE_FORMULA_FILEPATH_OLD
    unset PACKAGE_FORMULA_FILEPATH_NEW

    PACKAGE_FORMULA_FILEPATH_OLD="$XCPKG_FORMULA_REPO_DIR/$PACKAGE_FORMULA_REPO/formula/$1.yml"
    PACKAGE_FORMULA_FILEPATH_NEW="$XCPKG_FORMULA_REPO_DIR/$PACKAGE_FORMULA_REPO/formula/$2.yml"

    if [ -f "$PACKAGE_FORMULA_FILEPATH_NEW" ] ; then
        die "$2 package is already exist."
    fi

    if mv "$PACKAGE_FORMULA_FILEPATH_OLD" "$PACKAGE_FORMULA_FILEPATH_NEW" ; then
        success "rename formula $1 -> $2 success."
    else
        die "rename formula $1 -> $2 failed."
    fi
}

# __add_a_formula_repo <REPO-NAME> <REPO-URL> <GIT-BRANCH-NAME>
__add_a_formula_repo() {
    [ -z "$1" ] && die "please specify a repo name."
    [ -z "$2" ] && die "please specify a repo url."

    if [ -z "$XCPKG_URL_TRANSFORM" ] ; then
        GIT_FETCH_URL="$2"
    else
        GIT_FETCH_URL="$("$XCPKG_URL_TRANSFORM" "$2")" || return 1
    fi

    if [ -z "$3" ] ; then
        GIT_BRANCH_NAME=master
    else
        GIT_BRANCH_NAME="$3"
    fi

    FORMULA_REPO_PATH="$XCPKG_HOME/repos.d/$1"

    if [ -d "$FORMULA_REPO_PATH" ] ; then
        if git -C "$FORMULA_REPO_PATH" rev-parse HEAD > /dev/null 2>&1; then
            success "$1 formula repo already have been added."
            return 0
        else
            run rm -rf     "$FORMULA_REPO_PATH" || return 1
            run install -d "$FORMULA_REPO_PATH" || return 1
        fi
    else
        run install -d "$FORMULA_REPO_PATH" || return 1
    fi

    run git -C "$FORMULA_REPO_PATH" -c init.defaultBranch=master init || return 1
    run git -C "$FORMULA_REPO_PATH" remote add origin "$GIT_FETCH_URL" || return 1
    run git -C "$FORMULA_REPO_PATH" -c protocol.version=2 fetch --progress origin "+refs/heads/$GIT_BRANCH_NAME:refs/remotes/origin/$GIT_BRANCH_NAME" || return 1
    run git -C "$FORMULA_REPO_PATH" checkout --progress --force -B "$GIT_BRANCH_NAME" "refs/remotes/origin/$GIT_BRANCH_NAME" || return 1

    cat > "$FORMULA_REPO_PATH/.xcpkg-formula-repo.yml" <<EOF
url: $2
branch: $3
pinned: 0
enabled: 1
timestamp-added: $(date +%s)
EOF
}

# __del_a_formula_repo <REPO-NAME>
  __del_a_formula_repo() {
    [ -z "$1" ] && die "please specify a repo name."

    [ "$1" = 'offical-core' ] && die "offical-core formula repository is not allowed to delete."

    if [ -d    "$XCPKG_HOME/repos.d/$1" ] ; then
        rm -rf "$XCPKG_HOME/repos.d/$1"
    else
        warn "$1 named formula repo is not exist."
    fi
}

__repo_of_formula_of_the_given_package() {
    [ -z "$1" ] && {
        error "__repo_of_formula_of_the_given_package <PACKAGE-NAME>, <PACKAGE-NAME> is unspecified."
        return 1
    }

    for repoName in $(__list_available_formula_repository_names)
    do
        if [ -e "$XCPKG_FORMULA_REPO_DIR/$repoName/formula/$NATIVE_OS_TYPE/$1.yml" ] ; then
            printf '%s\n' "$repoName"
            return 0
        fi
        if [ -e "$XCPKG_FORMULA_REPO_DIR/$repoName/formula/$1.yml" ] ; then
            printf '%s\n' "$repoName"
            return 0
        fi
    done

    error "package [$1] is not available."
    return 1
}

# __path_of_formula_of_the_given_package <PACKAGE-NAME>
  __path_of_formula_of_the_given_package() {
    [ -z "$1" ] && {
        error "__path_of_formula_of_the_given_package <PACKAGE-NAME>, <PACKAGE-NAME> is unspecified."
        return 1
    }

    for repoName in $(__list_available_formula_repository_names)
    do
        if [ -e           "$XCPKG_FORMULA_REPO_DIR/$repoName/formula/$NATIVE_OS_TYPE/$1.yml" ] ; then
            printf '%s\n' "$XCPKG_FORMULA_REPO_DIR/$repoName/formula/$NATIVE_OS_TYPE/$1.yml"
            return 0
        fi
        if [ -e           "$XCPKG_FORMULA_REPO_DIR/$repoName/formula/$1.yml" ] ; then
            printf '%s\n' "$XCPKG_FORMULA_REPO_DIR/$repoName/formula/$1.yml"
            return 0
        fi
    done

    error "package [$1] is not available."
    return 1
}

__list_available_formula_repository_items() {
    if [ -d "$XCPKG_FORMULA_REPO_DIR" ] ; then
        I=0

        for item in $(cd "$XCPKG_FORMULA_REPO_DIR" && ls)
        do
            FORMULA_REPO_CONFIG_FILEPATH="$XCPKG_FORMULA_REPO_DIR/$item/.xcpkg-formula-repo.yml"

            if [ -f "$FORMULA_REPO_CONFIG_FILEPATH" ] ; then
                I=$(expr "$I" + 1)

                if [ "$I" -gt 1 ] ; then
                    printf '%s\n' '---'
                fi

                printf 'name: %s\n' "$item"
                printf 'path: %s\n' "$XCPKG_FORMULA_REPO_DIR/$item"
                cat "$FORMULA_REPO_CONFIG_FILEPATH"
            fi
        done
    fi
}

__list_available_formula_repository_names() {
    if [ -d "$XCPKG_FORMULA_REPO_DIR" ] ; then
        for item in $(cd "$XCPKG_FORMULA_REPO_DIR" && ls)
        do
            if [ -f "$XCPKG_FORMULA_REPO_DIR/$item/.xcpkg-formula-repo.yml" ] ; then
                printf '%s\n' "$item"
            fi
        done
    fi
}

__update_formula_repositories() {
    if [ -d "$XCPKG_FORMULA_REPO_DIR" ] ; then
        for item in $(cd "$XCPKG_FORMULA_REPO_DIR" && ls)
        do
            FORMULA_REPO_CONFIG_FILEPATH="$XCPKG_FORMULA_REPO_DIR/$item/.xcpkg-formula-repo.yml"

            if [ -f "$FORMULA_REPO_CONFIG_FILEPATH" ] ; then
                unset GIT_FETCH_URL
                unset GIT_BRANCH_NAME

                GIT_BRANCH_NAME="$(yq .branch "$FORMULA_REPO_CONFIG_FILEPATH")"
                GIT_FETCH_URL="$(yq .url "$FORMULA_REPO_CONFIG_FILEPATH")"

                if [ -n "$XCPKG_URL_TRANSFORM" ] ; then
                    GIT_FETCH_URL="$("$XCPKG_URL_TRANSFORM" "$GIT_FETCH_URL")" || return 1
                fi

                printf '%b\n' "${COLOR_PURPLE}==> Updating formula repository${COLOR_OFF} ${COLOR_GREEN}$item${COLOR_OFF}"

                FORMULA_REPO_PATH="$XCPKG_FORMULA_REPO_DIR/$item"

                if [ -z "$(git config remote.origin.url || true)" ] ; then
                    run git -C "$FORMULA_REPO_PATH" remote add     origin "$GIT_FETCH_URL" || return 1
                else
                    run git -C "$FORMULA_REPO_PATH" remote set-url origin "$GIT_FETCH_URL" || return 1
                fi

                run git -C "$FORMULA_REPO_PATH" -c protocol.version=2 fetch --progress origin "+refs/heads/$GIT_BRANCH_NAME:refs/remotes/origin/$GIT_BRANCH_NAME" || return 1
                run git -C "$FORMULA_REPO_PATH" checkout --progress --force -B "$GIT_BRANCH_NAME" "refs/remotes/origin/$GIT_BRANCH_NAME" || return 1

                if grep -q '^timestamp-last-updated: ' "$FORMULA_REPO_CONFIG_FILEPATH" ; then
                    sed -i "/timestamp-last-updated: /c timestamp-last-updated: $(date +%s)" "$FORMULA_REPO_CONFIG_FILEPATH"
                else
                    printf '%s\n' "timestamp-last-updated: $(date +%s)" >> "$FORMULA_REPO_CONFIG_FILEPATH"
                fi
            fi
        done
    fi

    if [ ! -d "$XCPKG_FORMULA_REPO_DIR/offical-core" ] ; then
        printf '%b\n' "${COLOR_PURPLE}==> Adding formula repository${COLOR_OFF} ${COLOR_GREEN}offical-core${COLOR_OFF}"
        __add_a_formula_repo offical-core "$XCPKG_OFFICAL_FORMULA_REPO_URL" master
    fi
}

# __list_available_formula_search_dirs
  __list_available_formula_search_dirs() {
    for repoName in $(__list_available_formula_repository_names)
    do
        if [ -d           "$XCPKG_FORMULA_REPO_DIR/$repoName/formula/$NATIVE_OS_TYPE" ] ; then
            printf '%s\n' "$XCPKG_FORMULA_REPO_DIR/$repoName/formula/$NATIVE_OS_TYPE"
        fi

        printf '%s\n' "$XCPKG_FORMULA_REPO_DIR/$repoName/formula"
    done
}

__list_formula_filepath() {
    {
        for FORMULA_SEARCH_DIR in $(__list_available_formula_search_dirs)
        do
            find "$FORMULA_SEARCH_DIR" -maxdepth 1 -type f -name '*.yml' || return 1
        done
    } | sort | uniq
}


# }}}
##############################################################################

prompt_user_to_install_bat() {
    echo
    note "${COLOR_YELLOW}if you want to have a better experience, I strongly recommend you to install${COLOR_OFF} ${COLOR_GREEN}bat${COLOR_OFF} ${COLOR_YELLOW}on this machine. For more details, please visit website${COLOR_OFF} ${COLOR_GREEN}https://github.com/sharkdp/bat${COLOR_OFF}"
}

# fetch source code if needed
__fetch_sources_of_the_given_package() {
    case $PACKAGE_SRC_FILETYPE in
        .dir) note "$PACKAGE_SRC_URL is local path, no need to fetch." ;;
        .git)
            unset GIT_FETCH_URL

            if [ -z "$XCPKG_URL_TRANSFORM" ] ; then
                GIT_FETCH_URL="$PACKAGE_GIT_URL"
            else
                GIT_FETCH_URL="$("$XCPKG_URL_TRANSFORM" "$PACKAGE_GIT_URL")" || return 1
            fi

            if [ -z "$PACKAGE_GIT_SHA" ] ; then
                if [ -z "$PACKAGE_GIT_REF" ] ; then
                    GIT_BRANCH_NAME=master
                    GIT_REF_SPEC="+HEAD:refs/remotes/origin/master"
                else
                    GIT_BRANCH_NAME="$(basename "$PACKAGE_GIT_REF")"
                    GIT_REF_SPEC="+$PACKAGE_GIT_REF:refs/remotes/origin/$GIT_BRANCH_NAME"
                fi
            else
                GIT_BRANCH_NAME=master
                GIT_REF_SPEC="+$PACKAGE_GIT_SHA:refs/remotes/origin/master"
            fi

            if [ "$PACKAGE_SHALLOW" = yes ] ; then
                GIT_FETCH_EXTRA_OPTIONS='--depth=1'
            else
                if [ -f "$PACKAGE_SRC_FILEPATH/.git/shallow" ] ; then
                    GIT_FETCH_EXTRA_OPTIONS='--unshallow'
                else
                    GIT_FETCH_EXTRA_OPTIONS=
                fi
            fi

            if [ -d "$PACKAGE_SRC_FILEPATH" ] ; then
                if git -C "$PACKAGE_SRC_FILEPATH" rev-parse HEAD > /dev/null 2>&1 ; then
                    if [ -n "$PACKAGE_GIT_SHA" ] && [ "$PACKAGE_GIT_SHA" = "$(git -C "$PACKAGE_SRC_FILEPATH" rev-parse HEAD)" ] ; then
                        success "$PACKAGE_SRC_FILEPATH already have been fetched."
                        return 0
                    fi
                else
                    run rm -rf     "$PACKAGE_SRC_FILEPATH" || return 1
                    run install -d "$PACKAGE_SRC_FILEPATH" || return 1
                    run git -C     "$PACKAGE_SRC_FILEPATH" -c init.defaultBranch=master init || return 1
                    run git -C     "$PACKAGE_SRC_FILEPATH" remote add origin "$GIT_FETCH_URL" || return 1
                fi
            else
                run install -d "$PACKAGE_SRC_FILEPATH" || return 1
                run git -C     "$PACKAGE_SRC_FILEPATH" -c init.defaultBranch=master init || return 1
                run git -C     "$PACKAGE_SRC_FILEPATH" remote add origin "$GIT_FETCH_URL" || return 1
            fi

            run git -C "$PACKAGE_SRC_FILEPATH" -c protocol.version=2 fetch --progress $GIT_FETCH_EXTRA_OPTIONS origin "$GIT_REF_SPEC" || return 1
            run git -C "$PACKAGE_SRC_FILEPATH" checkout --progress --force -B "$GIT_BRANCH_NAME" "refs/remotes/origin/$GIT_BRANCH_NAME" || return 1
            run git -C "$PACKAGE_SRC_FILEPATH" submodule update --init || return 1
            ;;
        *)  if [ -z    "$PACKAGE_SRC_URI" ] ; then
                wfetch "$PACKAGE_SRC_URL" --sha256="$PACKAGE_SRC_SHA" --output-path="$PACKAGE_SRC_FILEPATH"
            else
                wfetch "$PACKAGE_SRC_URL" --sha256="$PACKAGE_SRC_SHA" --output-path="$PACKAGE_SRC_FILEPATH" --uri="$PACKAGE_SRC_URI"
            fi
    esac
}

__fetch_patches_of_the_given_package() {
    if [ -n    "$PACKAGE_FIX_URL" ] ; then
        wfetch "$PACKAGE_FIX_URL" --sha256="$PACKAGE_FIX_SHA" --output-path="$PACKAGE_FIX_FILEPATH"
    fi
    if [ -n    "$PACKAGE_RES_URL" ] ; then
        wfetch "$PACKAGE_RES_URL" --sha256="$PACKAGE_RES_SHA" --output-path="$PACKAGE_RES_FILEPATH"
    fi
}

__fetch_resources_of_the_given_package() {
    [ -z "$1" ] && {
        error "__fetch_resources_of_the_given_package <PACKAGE-NAME>, <PACKAGE-NAME> is unspecified."
        return 1
    }

    case $1 in
        @all)
            shift
            unset STEP_NUM
            for PKG in $(__list_available_packages)
            do
                step "$PKG"
                 __load_formula_of_the_given_package "$PKG" $@
                __fetch_sources_of_the_given_package "$PKG" $@
                __fetch_patches_of_the_given_package "$PKG" $@
            done
            ;;
        *)
             __load_formula_of_the_given_package $@
            __fetch_sources_of_the_given_package $@
            __fetch_patches_of_the_given_package $@
    esac
}


die_if_package_is_not_specified() {
    [ -n "$1" ] || die "no package is specified."
}

die_if_package_is_not_available() {
    is_package_available "$1" || die "$1 is not available."
}

die_if_package_is_not_installed() {
    is_package_installed "$1" || die "$1 is not installed."
}

# check if the given package is available
# if the version condition is given, check if the condition is matched
#
# condition operator:
# eq  equal
# ne  not equal
# gt  greater than
# lt  less than
# ge  greater than or equal
# le  less than or equal
#
# examples:
# is_package_available automake eq 1.16.0
# is_package_available automake lt 1.16.0
# is_package_available automake gt 1.16.0
# is_package_available automake le 1.16.0
# is_package_available automake ge 1.16.0
# is_package_available automake
is_package_available() {
    case $# in
        0)  die_if_package_is_not_specified ;;
        1)  [ -n "$(__path_of_formula_of_the_given_package $1)" ] ;;
        3)  __load_formula_of_the_given_package "$1"
            shift
            version_match $PACKAGE_VERSION $@
            ;;
        *)  die "is available command only accept 1 or 3 argument."
    esac
}

# is_package_installed <PACKAGE-SPEC>
  is_package_installed() {
    [ -z "$1" ] && {
        error "is_package_installed <PACKAGE-SPEC>, <PACKAGE-SPEC> is unspecified."
        return 1
    }

    [ -f "$XCPKG_PACKAGE_INSTALLED_ROOT/$1/.xcpkg/buildon.yml" ]  || return 12
    [ -f "$XCPKG_PACKAGE_INSTALLED_ROOT/$1/.xcpkg/manifest.txt" ] || return 13
    [ -f "$XCPKG_PACKAGE_INSTALLED_ROOT/$1/.xcpkg/receipt.yml" ]  || return 14
}

# is_package__outdated <PACKAGE-SPEC>
  is_package__outdated() {
    __load_formula_of_the_given_package "$(basename "$1")"
    __load_receipt_of_the_given_package "$1"

    version_match "$PACKAGE_VERSION" gt "$INSTALLED_PACKAGE_VERSION"
}

__gen_github_workflows() {
    set -e

    unset BREAK
    unset NDEPENDED_PACKAGES
    unset AVAILABLE_PACKAGES
    unset GROUP_SIZE
    unset OUTPUT_DIR
    unset I

    while [ -n "$1" ]
    do
        case $1 in
            --group-size=*)
                GROUP_SIZE=$(getvalue "$1")
                is_integer "$GROUP_SIZE" || die "--group-size=INTEGER"
                ;;
            --output-dir=*)
                OUTPUT_DIR=$(getvalue "$1")
                case "$OUTPUT_DIR" in
                    '') die "--output-dir=<DIR>, DIR must be non-empty." ;;
                    /*) ;;
                    \~|\~/) OUTPUT_DIR="${HOME}" ;;
                    \~/*)   OUTPUT_DIR="${HOME}$(printf "$OUTPUT_DIR" | cut -c3-)" ;;
                    .|./)   OUTPUT_DIR="${PWD}" ;;
                    *)      OUTPUT_DIR="${PWD}/$OUTPUT_DIR" ;;
                esac
                [ -d "$OUTPUT_DIR" ] || run install -d "$OUTPUT_DIR"
        esac
        shift
    done

    if [ -z "$GROUP_SIZE" ] ; then
        die "please sepecify --group-size=INTEGER argument."
    fi

    if [ -z "$OUTPUT_DIR" ] ; then
        OUTPUT_DIR="$XCPKG_HOME/repos.d/offical-core/.github/workflows"
    fi

    GITHUB_ACTIONS_WORKFLOW_TEMPLATE_FILEPATH="$XCPKG_HOME/repos.d/offical-core/.github/workflows/template"

    if [ ! -f "$GITHUB_ACTIONS_WORKFLOW_TEMPLATE_FILEPATH" ] ; then
        __update_formula_repositories
    fi

    AVAILABLE_PACKAGES=$(__list_available_packages)

    for x in $AVAILABLE_PACKAGES
    do
        if [ "$x" = 'test' ] ; then
            continue
        fi
        for y in $AVAILABLE_PACKAGES
        do
            if [ "$x" = "$y" ] || [ 'test' = "$y" ] ; then
                continue
            else
                for z in $(get_direct_dependency_package_list_of_the_given_package "$y")
                do
                    if [ "$x" = "$z" ] ; then
                        BREAK=yes
                        break 2
                    fi
                done
            fi
        done
        if [ "$BREAK" = yes ] ; then
            unset BREAK
        else
            if [ -z "$NDEPENDED_PACKAGES" ] ; then
                NDEPENDED_PACKAGES="$x"
            else
                NDEPENDED_PACKAGES="$NDEPENDED_PACKAGES $x"
            fi
            if [ "$(list_length $NDEPENDED_PACKAGES)" -eq "$GROUP_SIZE" ] ; then
                unset OUTPUT_FILEPATH

                I=$(expr ${I-0} + 1)
                OUTPUT_FILEPATH="$OUTPUT_DIR/ci$I.yml"
                NDEPENDED_PACKAGES=$(echo "$NDEPENDED_PACKAGES" | tr ' ' ,)

                echo
                run cp "$GITHUB_ACTIONS_WORKFLOW_TEMPLATE_FILEPATH" "$OUTPUT_FILEPATH"
                sed_in_place "s/INDEX/$I/"                     "$OUTPUT_FILEPATH"
                sed_in_place "s/PKGLIST/$NDEPENDED_PACKAGES/"  "$OUTPUT_FILEPATH"

                unset NDEPENDED_PACKAGES
            fi
        fi
    done
    if [ -n "$NDEPENDED_PACKAGES" ] ; then
        unset OUTPUT_FILEPATH

        I=$(expr ${I-0} + 1)
        OUTPUT_FILEPATH="$OUTPUT_DIR/ci$I.yml"
        NDEPENDED_PACKAGES=$(echo "$NDEPENDED_PACKAGES" | tr ' ' ,)

        run cp "$GITHUB_ACTIONS_WORKFLOW_TEMPLATE_FILEPATH" "$OUTPUT_FILEPATH"
        sed_in_place "s/INDEX/$I/"                     "$OUTPUT_FILEPATH"
        sed_in_place "s/PKGLIST/$NDEPENDED_PACKAGES/"  "$OUTPUT_FILEPATH"
    fi
}

__search_packages() {
    [ -z "$1" ] && {
        error "please specify a regular express pattern."
        return 1
    }

    __list_available_packages | grep "$*"
}

__list_available_packages() {
    {
        for FORMULA_SEARCH_DIR in $(__list_available_formula_search_dirs)
        do
            find "$FORMULA_SEARCH_DIR" -maxdepth 1 -type f -name '*.yml' -exec basename {} .yml \; || return 1
        done
    } | sort | uniq
}

__list_installed_packages() {
    if [ -d "$XCPKG_PACKAGE_INSTALLED_ROOT" ] ; then
         cd "$XCPKG_PACKAGE_INSTALLED_ROOT" 2>/dev/null || return 1
    else
        return 0
    fi

    for packageName in *
    do
        if is_package_installed "$packageName" ; then
            echo "$packageName"
        fi
    done
}

__list__outdated_packages() {
    if [ -d "$XCPKG_PACKAGE_INSTALLED_ROOT" ] ; then
         cd "$XCPKG_PACKAGE_INSTALLED_ROOT" 2>/dev/null || return 1
    else
        return 0
    fi

    for packageName in *
    do
        is_package_available "$packageName" || continue
        is_package_installed "$packageName" || continue
        is_package__outdated "$packageName" || continue
        echo "$packageName"
    done
}

# __tree_the_given_installed_package <PACKAGE-SPEC>
  __tree_the_given_installed_package() {
    die_if_package_is_not_installed "$1"
    run tree $(shiftn 1 $@) "$XCPKG_PACKAGE_INSTALLED_ROOT/$1"
}

__uninstall_the_given_packages() {
    die_if_package_is_not_specified "$1"

    for packageName in $@
    do
        __uninstall_the_given_package "$packageName" || return 1
    done
}

# __uninstall_the_given_package <PACKAGE-SPEC>
  __uninstall_the_given_package() {
    die_if_package_is_not_installed "$1"

    run rm -rf "$XCPKG_PACKAGE_INSTALLED_ROOT/$1"
}

__reinstall_the_given_packages() {
    inspect_install_arguments $@

    die_if_package_is_not_specified $USER_SPECIFIED_PACKAGE_SPEC_LIST

    for packageName in $USER_SPECIFIED_PACKAGE_SPEC_LIST
    do
        die_if_package_is_not_available "$packageName"
        die_if_package_is_not_installed "$packageName"
    done

    for PACKAGE_NAME in $USER_SPECIFIED_PACKAGE_SPEC_LIST
    do
        [ -d "$XCPKG_BACKUP_DIR" ] || {
            install -d "$XCPKG_BACKUP_DIR" || return 1
        }

        mv "$XCPKG_PACKAGE_INSTALLED_ROOT/$PACKAGE_NAME" "$XCPKG_BACKUP_DIR/$PACKAGE_NAME" || return 1

        (__install_the_given_package "$PACKAGE_NAME") || return 1

        rm -rf "$XCPKG_BACKUP_DIR/$PACKAGE_NAME" || return 1
    done
}

__upgrade_packages() {
    inspect_install_arguments $@

    if [ -z "$USER_SPECIFIED_PACKAGE_SPEC_LIST" ] ; then
        USER_SPECIFIED_PACKAGE_SPEC_LIST=$(__list__outdated_packages)
    fi

    for packageName in $USER_SPECIFIED_PACKAGE_SPEC_LIST
    do
        die_if_package_is_not_available "$packageName"
        die_if_package_is_not_installed "$packageName"
    done

    for PACKAGE_NAME in $USER_SPECIFIED_PACKAGE_SPEC_LIST
    do
        [ -d "$XCPKG_BACKUP_DIR" ] || {
            install -d "$XCPKG_BACKUP_DIR" || return 1
        }

        mv "$XCPKG_PACKAGE_INSTALLED_ROOT/$PACKAGE_NAME" "$XCPKG_BACKUP_DIR/$PACKAGE_NAME" || return 1

        (__install_the_given_package "$PACKAGE_NAME") || return 1

        rm -rf "$XCPKG_BACKUP_DIR/$PACKAGE_NAME" || return 1
    done
}

__cleanup() {
    success "Done."
}

package_name_transform_from_uppm_to_brew() {
    case $1 in
        file)     printf '%s\n' 'file-formula' ;;
        delta)    printf '%s\n' 'git-delta' ;;
        gmake)    printf '%s\n' 'make'      ;;
        gtar)     printf '%s\n' 'gnu-tar'   ;;
        gm4)      printf '%s\n' 'm4'        ;;
        libjxl)   printf '%s\n' 'jpeg-xl'   ;;
        blake3)   printf '%s\n' 'b3sum'     ;;
        libwebp)  printf '%s\n' 'webp'      ;;
        proj7)    printf '%s\n' 'proj@7'    ;;
        openssl)  printf '%s\n' 'openssl@1.1';;
        freetype2)printf '%s\n' 'freetype'  ;;
        freetype2-with-harfbuzz)
                  printf '%s\n' 'freetype'  ;;
        gnu-coreutils)
                  printf '%s\n' 'coreutils' ;;
        libmediainfo|mediainfo)
                  printf '%s\n' 'media-info';;
        tcl-core) printf '%s\n' 'tcl-tk'    ;;
        *)        printf '%s\n' "$1"
    esac
}


__compare_versions_with_brew() {
    set -e

    cd "$XCPKG_HOME/repos.d/offical-core/formula"

    for item in $(ls -1 *.yml | sed 's/\.yml$//')
    do
        __load_formula_of_the_given_package "$item"

        BREW_PKG_NMAE="$(package_name_transform_from_uppm_to_brew $PACKAGE_NAME)"

        if brew info "$BREW_PKG_NMAE" > /dev/null 2>&1 ; then
            BREW_PKG_VERS=$(__pmw_get_available_package_version_by_package_name brew "$BREW_PKG_NMAE")

            if version_match "$BREW_PKG_VERS" gt "$PACKAGE_VERSION" ; then
                printf "${COLOR_RED}%-10s %-10s  |  %-10s %-10s${COLOR_OFF}\n" "$PACKAGE_NAME" "$PACKAGE_VERSION" "$BREW_PKG_NMAE" "$BREW_PKG_VERS"
            else
                :
                #printf "${COLOR_GREEN}%-10s %-10s  |  %-10s %-10s${COLOR_OFF}\n" "$PACKAGE_NAME" "$PACKAGE_VERSION" "$BREW_PKG_NMAE" "$BREW_PKG_VERS"
            fi
        else
            printf "${COLOR_BLUE}%-10s %-10s  |${COLOR_OFF}\n" "$PACKAGE_NAME" "$PACKAGE_VERSION"
        fi
    done
}

__show_or_open_homepage_of_the_given_package() {
    unset ACTION
    unset PACKAGE

    while [ -n "$1" ]
    do
        case $1 in
            --open)
                ACTION=open
                ;;
            -*|--*)
                die "unrecognized argument: 41"
                ;;
            *)  if [ -z "$PACKAGE" ] ; then
                    PACKAGE=$1
                else
                    die "too many packages given."
                fi
        esac
        shift
    done

    if [ "$ACTION" = open ] ; then
        __open_homepage_of_the_given_package $PACKAGE
    else
        __show_homepage_of_the_given_package $PACKAGE
    fi
}

__show_homepage_of_the_given_package() {
    if [ -z "$1" ] ; then
        PACKAGE_WEB_URL="$XCPKG_WEB_URL"
    else
        __load_formula_of_the_given_package "$1"
    fi

    echo "$PACKAGE_WEB_URL"
}

__open_homepage_of_the_given_package() {
    if [ -z "$1" ] ; then
        PACKAGE_WEB_URL="$XCPKG_WEB_URL"
    else
        __load_formula_of_the_given_package "$1"
    fi
    
    if command -v open > /dev/null ; then
        run "open '$PACKAGE_WEB_URL'"
    elif command -v termux-open-url > /dev/null ; then
        run "termux-open-url '$PACKAGE_WEB_URL'"
    else
        warn "I don't konw how to open"
    fi
}

# __show_packages_depended_by_the_given_package <PACKAGE-NAME> [-t <dot|box|svg|png>] [-o <OUTPUT-PATH>]
__show_packages_depended_by_the_given_package() {
    [ -z "$1" ] && {
        error "__show_packages_depended_by_the_given_package <PACKAGE-NAME> [-t <OUTPUT-TYPE>] [-o <OUTPUT-PATH>], <PACKAGE-NAME> is unspecified."
        return 1
    }

    PACKAGE_NAME="$1"

    shift

    ###########################################################################################

    unset OUTPUT_FILETYPE
    unset OUTPUT_FILEPATH

    while [ -n "$1" ]
    do
        case $1 in
            -t) shift
                case $1 in
                    dot|box|svg|png)
                        OUTPUT_FILETYPE="$1" ;;
                    '') die "$_0 depends <PACKAGE-NAME> [-t <OUTPUT-TYPE>] [-o <OUTPUT-PATH>], -t option is given but <OUTPUT-TYPE> is unspecified." ;;
                    *)  die "$_0 depends <PACKAGE-NAME> [-t <OUTPUT-TYPE>], unsupported <OUTPUT-TYPE>: $1, <OUTPUT-TYPE> should be one of dot|box|svg|png"
                esac
                ;;
            -o) shift
                if [ -z "$1" ] ; then
                    die "$_0 depends <PACKAGE-NAME> [-t <OUTPUT-TYPE>] [-o <OUTPUT-PATH>], -o option is given but <OUTPUT-PATH> is unspecified."
                else
                    OUTPUT_FILEPATH="$1"
                fi
                ;;
            *)  die "$_0 depends <PACKAGE-NAME> [-t <OUTPUT-TYPE>] [-o <OUTPUT-PATH>] [--keep-packing-dir], unrecognized option: $1"
        esac
        shift
    done

    ###########################################################################################

    if [ -z "$OUTPUT_FILEPATH" ] ; then
        if [ -z "$OUTPUT_FILETYPE" ] ; then
            OUTPUT_FILETYPE='box'
        fi
    else
        if [ -d "$OUTPUT_FILEPATH" ] ; then
            if [ -z "$OUTPUT_FILETYPE" ] ; then
                OUTPUT_FILETYPE='box'
            fi

            unset OUTPUT_DIR
            OUTPUT_DIR="$(realpath -s "$OUTPUT_FILEPATH")"


            OUTPUT_FILEPATH="$OUTPUT_DIR/$PACKAGE_NAME-dependencies.$OUTPUT_FILETYPE"
        else
            case $OUTPUT_FILEPATH in
                */)
                    if [ -z "$OUTPUT_FILETYPE" ] ; then
                        OUTPUT_FILETYPE='box'
                    fi

                    unset OUTPUT_DIR
                    OUTPUT_DIR="$(realpath -s "$OUTPUT_FILEPATH")"

                    OUTPUT_FILEPATH="$OUTPUT_DIR/$PACKAGE_NAME-dependencies.$OUTPUT_FILETYPE"

                    [ -d "$OUTPUT_DIR" ] || install -d "$OUTPUT_DIR"
                    ;;
                *)
                    OUTPUT_FILEPATH="$(realpath -s "$OUTPUT_FILEPATH")"

                    unset OUTPUT_DIR
                    OUTPUT_DIR="$(dirname "$OUTPUT_FILEPATH")"

                    [ -d "$OUTPUT_DIR" ] || install -d "$OUTPUT_DIR"

                    if [ -z "$OUTPUT_FILETYPE" ] ; then
                        case $OUTPUT_FILEPATH in
                            *.box)
                                OUTPUT_FILETYPE=box
                                ;;
                            *.dot)
                                OUTPUT_FILETYPE=dot
                                ;;
                            *.svg)
                                OUTPUT_FILETYPE=svg
                                ;;
                            *.png)
                                OUTPUT_FILETYPE=png
                                ;;
                            *)  die "when -t <OUTPUT-TYPE> option is not given, -o <OUTPUT-PATH> option specified filename must ends with one of .dot|.box|.svg|.png"
                        esac
                    fi
            esac
        fi
    fi

    ###########################################################################################

    __gen_dependency_graph_recursively_depended_by_the_given_package "$PACKAGE_NAME" "$OUTPUT_FILETYPE" "$OUTPUT_FILEPATH"
}

# __logs_the_given_installed_package <PACKAGE-SPEC>
  __logs_the_given_installed_package() {
    [ -z "$1" ] && {
        error "$_0 logs <PACKAGE-SPEC>, <PACKAGE-SPEC> is unspecified."
        return 1
    }

    if command -v bat > /dev/null ; then
        VIEWER=bat
    else
        VIEWER=less
    fi

    for item in $(ls "$XCPKG_PACKAGE_INSTALLED_ROOT/$1/.xcpkg")
    do
        item="$XCPKG_PACKAGE_INSTALLED_ROOT/$1/.xcpkg/$item"

        if [ -d "$item" ] ; then
            continue
        fi

        if [ "$VIEWER" = 'bat' ] ; then
            case $item in
                *.png) ;;
                */receipt.yml)
                    bat -l yaml "$item" ;;
                *)  bat "$item"
            esac
        else
            "$VIEWER" "$item"
        fi
    done

    if [ "$VIEWER" != 'bat' ] ; then
        prompt_user_to_install_bat
    fi
}

# examples:
# __pack_the_given_installed_package <PACKAGE-NAME> [-t <zip|tar.gz|tar.xz|tar.lz|tar.bz2>] [-o <OUTPUT-PATH>] [--keep-packing-dir]
# __pack_the_given_installed_package    autoconf     -t tar.xz
  __pack_the_given_installed_package() {
    __load_receipt_of_the_given_package "$1"

    TARGET_PLATFORM_ARCH="$(printf '%s\n' "$1" | cut -d/ -f3)"
    RECEIPT_PACKAGE_NAME="$(printf '%s\n' "$1" | cut -d/ -f4)"

    shift

    ###########################################################################################

    unset OUTPUT_DIR
    unset OUTPUT_FILETYPE
    unset OUTPUT_FILEPATH

    while [ -n "$1" ]
    do
        case $1 in
            --keep-packing-dir)
                KEEP_PACKING_DIR=yes
                ;;
            -t) shift

                if [ -z "$1" ] ; then
                    die "$_0 pack <PACKAGE-NAME> [-t <OUTPUT-TYPE>] [-o <OUTPUT-PATH>], -t option is given but <OUTPUT-TYPE> is unspecified."
                else
                    OUTPUT_FILETYPE="$1"
                fi

                case $OUTPUT_FILETYPE in
                    zip|tar.gz|tar.xz|tar.lz|tar.bz2) ;;
                    *) die "$_0 pack <PACKAGE-NAME> [-t <OUTPUT-TYPE>], unsupported <OUTPU-TYPE>: $OUTPUT_FILETYPE, <OUTPU-TYPE> should be one of zip|tar.gz|tar.xz|tar.lz|tar.bz2"
                esac
                ;;
            -o) shift
                if [ -z "$1" ] ; then
                    die "$_0 pack <PACKAGE-NAME> [-t <OUTPU-TYPE>] [-o <OUTPUT-PATH>], -o option is given but <OUTPUT-PATH> is unspecified."
                else
                    OUTPUT_FILEPATH="$1"
                fi
                ;;
            *)  die "$_0 pack <PACKAGE-NAME> [-t <OUTPUT-TYPE>] [-o <OUTPUT-PATH>] [--keep-packing-dir], unrecognized option: $1"
        esac
        shift
    done

    PACKED_DIR_NAME="$RECEIPT_PACKAGE_NAME-$RECEIPT_PACKAGE_VERSION-macos-$TARGET_PLATFORM_ARCH"

    ###########################################################################################

    if [ -z "$OUTPUT_FILEPATH" ] ; then
        if [ -z "$OUTPUT_FILETYPE" ] ; then
            OUTPUT_FILETYPE='tar.xz'
        fi

        OUTPUT_DIR="$XCPKG_HOME/packed"
        OUTPUT_FILENAME="$PACKED_DIR_NAME.$OUTPUT_FILETYPE"
    else
        if [ -d "$OUTPUT_FILEPATH" ] ; then
            if [ -z "$OUTPUT_FILETYPE" ] ; then
                OUTPUT_FILETYPE='tar.xz'
            fi

            OUTPUT_DIR="$(realpath -s "$OUTPUT_FILEPATH")"
            OUTPUT_FILENAME="$PACKED_DIR_NAME.$OUTPUT_FILETYPE"
        else
            case $OUTPUT_FILEPATH in
                */)
                    if [ -z "$OUTPUT_FILETYPE" ] ; then
                        OUTPUT_FILETYPE='tar.xz'
                    fi

                    OUTPUT_DIR="$(realpath -s "$OUTPUT_FILEPATH")"
                    OUTPUT_FILENAME="$PACKED_DIR_NAME.$OUTPUT_FILETYPE"
                    ;;
                *)
                    OUTPUT_FILEPATH="$(realpath -s "$OUTPUT_FILEPATH")"

                    if [ -z "$OUTPUT_FILETYPE" ] ; then
                        case $OUTPUT_FILEPATH in
                            *.tar.gz|*.tgz)
                                OUTPUT_FILETYPE=tar.gz
                                ;;
                            *.tar.xz|*.txz)
                                OUTPUT_FILETYPE=tar.xz
                                ;;
                            *.tar.lz|*.tlz)
                                OUTPUT_FILETYPE=tar.lz
                                ;;
                            *.tar.bz2|*.tbz2)
                                OUTPUT_FILETYPE=tar.bz2
                                ;;
                            *.zip)
                                OUTPUT_FILETYPE=zip
                                ;;
                            *.7z)
                                OUTPUT_FILETYPE=7z
                                ;;
                            *)  die "when -t <OUTPUT-TYPE> option is not given, -o <OUTPUT-PATH> option specified filename must ends with one of .tar.gz|.tar.xz|.tar.lz|.tar.bz2|.tgz|.txz|.tlz|.tbz2|.zip|.7z"
                        esac
                    fi

                    OUTPUT_DIR="$(dirname "$OUTPUT_FILEPATH")"
                    OUTPUT_FILENAME="$(basename "$OUTPUT_FILEPATH")"
            esac
        fi
    fi

    ###########################################################################################

    step "create packing directory"
    printf '%b\n' "$COLOR_PURPLE==>$COLOR_OFF ${COLOR_GREEN}mktemp -d$COLOR_OFF"
    PACKING_DIR=$(mktemp -d)

    step "change to packing directory"
    run cd $PACKING_DIR

    step "make link refer to installed package root dir"
    run ln -s "$PACKAGE_INSTALLED_DIR" "$PACKED_DIR_NAME"

    step "packing"
    case $OUTPUT_FILETYPE in
        zip) run zip -9 -r     "$OUTPUT_FILENAME" "$PACKED_DIR_NAME" ;;
        7z)  run 7za a -t7z -r "$OUTPUT_FILENAME" "$PACKED_DIR_NAME/*" "$PACKED_DIR_NAME/.xcpkg" ;;
        tar.xz)  run tar cv --xz    -f "$OUTPUT_FILENAME" "$PACKED_DIR_NAME/*" "$PACKED_DIR_NAME/.xcpkg" ;;
        tar.gz)  run tar cv --gzip  -f "$OUTPUT_FILENAME" "$PACKED_DIR_NAME/*" "$PACKED_DIR_NAME/.xcpkg" ;;
        tar.lz)  run tar cv --lzip  -f "$OUTPUT_FILENAME" "$PACKED_DIR_NAME/*" "$PACKED_DIR_NAME/.xcpkg" ;;
        tar.bz2) run tar cv --bzip2 -f "$OUTPUT_FILENAME" "$PACKED_DIR_NAME/*" "$PACKED_DIR_NAME/.xcpkg" ;;
    esac

    step "check integrity of packed file"
    case $OUTPUT_FILETYPE in
        7z)    run 7za t -t7z "$OUTPUT_FILENAME" ;;
        zip)   run unzip -t   "$OUTPUT_FILENAME" ;;
        tar.*) run tar   -tf  "$OUTPUT_FILENAME" ;;
    esac

    step "show size of packed file"
    run "du -sh $OUTPUT_FILENAME | cut -f1"

    if [ ! -d "$OUTPUT_DIR" ] ; then
        step "create output dir"
        run install -d "$OUTPUT_DIR"
    fi

    step "copy packed file to output dir"
    run cp "$OUTPUT_FILENAME" "$OUTPUT_DIR/"

    if [ "$KEEP_PACKING_DIR" = yes ] ; then
        echo
        note "the work dir [$PACKING_DIR] is not deleted as --keep-packing-dir option is given."
    else
        step "delete packing directory"
        run rm -rf $PACKING_DIR
    fi

}

# this fuction should be run in subshell
# __get_packages_that_are_directly_depended_by_the_given_package <PACKAGE-NAME>
  __get_packages_that_are_directly_depended_by_the_given_package() {
      __load_formula_of_the_given_package "$1" && printf '%s\n' "$PACKAGE_DEP_PKG"
}

# this fuction should be run in subshell
#
# __get_packages_that_are_recursively_depended_by_the_given_package <PACKAGE-NAME>
# __get_packages_that_are_recursively_depended_by_the_given_package <PACKAGE-NAME> internal
  __get_packages_that_are_recursively_depended_by_the_given_package() {
    [ -z "$1" ] && {
        error "__get_packages_that_are_recursively_depended_by_the_given_package <PACKAGE-NAME> [internal], <PACKAGE-NAME> is unspecified."
        return 1
    }

    unset DIRECT_DEPENDENT_PACKAGES
    DIRECT_DEPENDENT_PACKAGES=$(__get_packages_that_are_directly_depended_by_the_given_package "$1")

    [ "$2" != internal ] && {
        DEPTH=1
        RESULT=
    }

    DEPTH=$(expr "$DEPTH" + 1)

    for DIRECT_DEPENDENT_PACKAGE_NAME in $DIRECT_DEPENDENT_PACKAGES
    do
        is_package_available "$DIRECT_DEPENDENT_PACKAGE_NAME" || {
            error "package [$DIRECT_DEPENDENT_PACKAGE_NAME] is not available."
            return 1
        }

        if [ "$(printf '%s\n' "$RESULT" | sed -n "/^$DIRECT_DEPENDENT_PACKAGE_NAME$/p")" = "$DIRECT_DEPENDENT_PACKAGE_NAME" ] ; then
            RESULT=$(printf '%s\n' "$RESULT" | sed "/^$DIRECT_DEPENDENT_PACKAGE_NAME$/d")
        fi

        if [ -z "$RESULT" ] ; then
            RESULT="$DIRECT_DEPENDENT_PACKAGE_NAME"
        else
            RESULT="$DIRECT_DEPENDENT_PACKAGE_NAME
$RESULT"
        fi

        __get_packages_that_are_recursively_depended_by_the_given_package "$DIRECT_DEPENDENT_PACKAGE_NAME" internal
    done

    DEPTH=$(expr "$DEPTH" - 1)

    if [ "$DEPTH" -eq 1 ] ; then
        printf '%s\n' "$RESULT"
    fi
}

__get_dot_file_contents() {
    for PKG in $@
    do
        unset DIRECT_DEPENDENT_PACKAGES
        DIRECT_DEPENDENT_PACKAGES="$(__get_packages_that_are_directly_depended_by_the_given_package "$PKG")"
        if [ -n "$DIRECT_DEPENDENT_PACKAGES" ] ; then
            printf '"%s" -> { "%s" }\n' "$PKG" "$(printf '%s\n' "$DIRECT_DEPENDENT_PACKAGES" | sed 's/ /" "/g')"
            __get_dot_file_contents $DIRECT_DEPENDENT_PACKAGES
        fi
    done
}

# __gen_dependency_graph_recursively_depended_by_the_given_package <PACKAGE-NAME> <dot|box|svg|png> [OUTPUT-FILEPATH]
__gen_dependency_graph_recursively_depended_by_the_given_package() {
    unset DIRECT_DEPENDENT_PACKAGES
    DIRECT_DEPENDENT_PACKAGES="$(__get_packages_that_are_directly_depended_by_the_given_package "$1")"

    if [ -z "$DIRECT_DEPENDENT_PACKAGES" ] ; then
        return 0
    fi

    case $2 in
        dot|box|svg|png) ;;
        '') die "__gen_dependency_graph_recursively_depended_by_the_given_package <PKG> <dot|txt|png> , format must be non-empty." ;;
        *)  die "__gen_dependency_graph_recursively_depended_by_the_given_package <PKG> <dot|txt|png> , unrecognized format: $2"
    esac

    unset GEN_DEPENDENCY_GRAPH_WORKING_DIR
    unset GEN_DEPENDENCY_GRAPH_DOT_FILEPATH

    GEN_DEPENDENCY_GRAPH_WORKING_DIR=$(mktemp -d) || return 1
    GEN_DEPENDENCY_GRAPH_DOT_FILEPATH="$GEN_DEPENDENCY_GRAPH_WORKING_DIR/dependencies.dot"

    printf 'digraph G {\n'       >  "$GEN_DEPENDENCY_GRAPH_DOT_FILEPATH"
    __get_dot_file_contents "$1" >> "$GEN_DEPENDENCY_GRAPH_DOT_FILEPATH"
    printf '}\n'                 >> "$GEN_DEPENDENCY_GRAPH_DOT_FILEPATH"

    case $2 in
        dot)
            if [ -z "$3" ] ; then
                cat "$GEN_DEPENDENCY_GRAPH_DOT_FILEPATH"
            else
                cp  "$GEN_DEPENDENCY_GRAPH_DOT_FILEPATH" "$3"
            fi
            ;;
        box)
            if [ -z "$3" ] ; then
                CURL_OPTS=
            else
                CURL_OPTS="-o $3"
            fi

            # https://github.com/ggerganov/dot-to-ascii
            curl $CURL_OPTS \
                -s \
                -G \
                --data-urlencode "boxart=1" \
                --data-urlencode "src=$(cat $GEN_DEPENDENCY_GRAPH_DOT_FILEPATH)" \
                "https://dot-to-ascii.ggerganov.com/dot-to-ascii.php"
            ;;
        svg)
            command -v dot > /dev/null || "$CURRENT_SCRIPT_FILEPATH" install graphviz || return 1

            if command -v fc-match > /dev/null ; then
                # Error: fontconfig: Couldn't find font.
                if [ -z "$(fc-match)" ] ; then
                    wfetch 'https://github.com/ryanoasis/nerd-fonts/blob/master/patched-fonts/Meslo/M/Regular/complete/Meslo%20LG%20M%20Regular%20Nerd%20Font%20Complete%20Mono%20Windows%20Compatible.ttf?raw=true' --output-dir="$HOME/.fonts" --output-name='Meslo LG M DZ Regular Nerd Font Complete Mono.ttf' || return 1
                fi
            fi

            if [ -z "$3" ] ; then
                run dot -Tsvg "$GEN_DEPENDENCY_GRAPH_DOT_FILEPATH"
            else
                run dot -Tsvg "-o$3" "$GEN_DEPENDENCY_GRAPH_DOT_FILEPATH"
            fi
            ;;
        png)
            command -v dot > /dev/null || "$CURRENT_SCRIPT_FILEPATH" install graphviz || return 1

            if command -v fc-match > /dev/null ; then
                # Error: fontconfig: Couldn't find font.
                if [ -z "$(fc-match)" ] ; then
                    wfetch 'https://github.com/ryanoasis/nerd-fonts/blob/master/patched-fonts/Meslo/M/Regular/complete/Meslo%20LG%20M%20Regular%20Nerd%20Font%20Complete%20Mono%20Windows%20Compatible.ttf?raw=true' --output-dir="$HOME/.fonts" --output-name='Meslo LG M DZ Regular Nerd Font Complete Mono.ttf' || return 1
                fi
            fi

            if [ -z "$3" ] ; then
                run dot -Tpng "$GEN_DEPENDENCY_GRAPH_DOT_FILEPATH"
            else
                run dot -Tpng "-o$3" "$GEN_DEPENDENCY_GRAPH_DOT_FILEPATH"
            fi
            ;;
    esac
}

__install_the_given_packages() {
    inspect_install_arguments $@

    [ -z "$USER_SPECIFIED_PACKAGE_SPEC_LIST" ] && {
        error "$_0 install <PACKAGE-SPEC|PACKAGE-NAME>..., <|PACKAGE-SPEC|PACKAGE-NAME> is unspecified."
        return 1
    }

    for PACKAGE_SPEC in $USER_SPECIFIED_PACKAGE_SPEC_LIST
    do
        unset PACKAGE_NAME

        unset TARGET_PLATFORM_NAME
        unset TARGET_PLATFORM_VERS
        unset TARGET_PLATFORM_ARCH

        TARGET_PLATFORM_NAME=$(printf '%s\n' "$PACKAGE_SPEC" | cut -d/ -f1)
        TARGET_PLATFORM_VERS=$(printf '%s\n' "$PACKAGE_SPEC" | cut -d/ -f2)
        TARGET_PLATFORM_ARCH=$(printf '%s\n' "$PACKAGE_SPEC" | cut -d/ -f3)
                PACKAGE_NAME=$(printf '%s\n' "$PACKAGE_SPEC" | cut -d/ -f4)

        unset RECURSIVE_DEPENDENT_PACKAGES
        RECURSIVE_DEPENDENT_PACKAGES="$(__get_packages_that_are_recursively_depended_by_the_given_package $PACKAGE_NAME) $PACKAGE_NAME"

        if [ $(list_length $RECURSIVE_DEPENDENT_PACKAGES) -gt 1 ] ; then
            RECURSIVE_DEPENDENT_PACKAGES="$(printf '%s\n' "$RECURSIVE_DEPENDENT_PACKAGES" | tr '\n' ' ')"
            printf '%b\n' "$COLOR_PURPLE==>$COLOR_OFF to install$COLOR_GREEN $RECURSIVE_DEPENDENT_PACKAGES $COLOR_OFF\n"
        fi

        for PACKAGE_NAME in $RECURSIVE_DEPENDENT_PACKAGES
        do
            PACKAGE_SPEC="$TARGET_PLATFORM_NAME/$TARGET_PLATFORM_VERS/$TARGET_PLATFORM_ARCH/$PACKAGE_NAME"

            if is_package_installed "$PACKAGE_SPEC" ; then
                if [ "$LOG_LEVEL" -gt 0 ] ; then
                    printf "$COLOR_GREEN%-10s$COLOR_OFF already have been installed.\n" "$PACKAGE_SPEC"
                fi
            else
                (__install_the_given_package "$PACKAGE_SPEC")

                if [ "$DRYRUN" = no ] ; then
                    is_package_installed "$PACKAGE_SPEC" || die "package [$PACKAGE_SPEC] install failed"
                fi
            fi
        done
    done
}

# Note: this function must run in a subshell
__install_the_given_package() {
    echo "${COLOR_PURPLE}=============== Installing ${COLOR_OFF}${COLOR_GREEN}${1}${COLOR_OFF}${COLOR_PURPLE} ===============${COLOR_OFF}"

    # brew install meson
    # Error: The current work directory doesn't exist, cannot proceed.
    # beacuse previous package's work direcotory is deleted.
    cd ~

    unset CONFIG_XX_UPDATED

    step "view formula"
    __view_formula_of_the_given_package "$PACKAGE_NAME" --paging=never

    step "load formula"
    __load_formula_of_the_given_package "$PACKAGE_NAME"

    #########################################################################################

    if [ -z "$TARGET_PLATFORM_VERS_ALLOWED_MIN" ] ; then
        # no limit
        :
    else
        :
    fi

    #########################################################################################

    if [ "$PACKAGE_BUILD_SYSTEM_GMAKE" = yes ] && [ "$EXPORT_COMPILE_COMMANDS_JSON" = yes ] && [ "$BEAR_ENABLED" = yes ] ; then
        PACKAGE_DEP_UPP="$PACKAGE_DEP_UPP bear"
    fi

    if [ "$CCACHE_ENABLED" = yes ] ; then
        PACKAGE_DEP_UPP="$PACKAGE_DEP_UPP ccache"
    fi

    #########################################################################################

    [ -n "$PACKAGE_DEP_UPP" ] && {
        if [ "$XCPKG_USE_BREW" = yes ] ; then
            step "install needed packages via brew"

            unset BREW; BREW=$(command -v brew)

            run "$BREW" update
            run "$BREW" --env

            for item in $PACKAGE_DEP_UPP
            do
                unset BREW_PACKAGE_NAME; BREW_PACKAGE_NAME=$(package_name_transform_from_uppm_to_brew "$item")

                run "$BREW" install "$BREW_PACKAGE_NAME"

                unset BREW_PACKAGE_INSTALLED_DIR; BREW_PACKAGE_INSTALLED_DIR="$("$BREW" --prefix "$BREW_PACKAGE_NAME")"

                if [ -d  "$BREW_PACKAGE_INSTALLED_DIR/bin" ] ; then
                    PATH="$BREW_PACKAGE_INSTALLED_DIR/bin:$PATH"
                fi

                if [ -d  "$BREW_PACKAGE_INSTALLED_DIR/sbin" ] ; then
                    PATH="$BREW_PACKAGE_INSTALLED_DIR/sbin:$PATH"
                fi

                if [ -d  "$BREW_PACKAGE_INSTALLED_DIR/libexec/gnubin" ] ; then
                    PATH="$BREW_PACKAGE_INSTALLED_DIR/libexec/gnubin:$PATH"
                fi
            done
        else
            step "install needed packages via uppm"

            UPPM="$XCPKG_CORE_BIN_DIR/uppm"

            run "$UPPM" env
            run "$UPPM" update

            for item in $PACKAGE_DEP_UPP
            do
                run "$UPPM" install "$item"

                unset UPPM_PACKAGE_INSTALLED_DIR
                UPPM_PACKAGE_INSTALLED_DIR="$("$UPPM" info "$item" installed-dir)"

                if [ -d  "$UPPM_PACKAGE_INSTALLED_DIR/bin" ] ; then
                    PATH="$UPPM_PACKAGE_INSTALLED_DIR/bin:$PATH"
                fi

                if [ -d  "$UPPM_PACKAGE_INSTALLED_DIR/sbin" ] ; then
                    PATH="$UPPM_PACKAGE_INSTALLED_DIR/sbin:$PATH"
                fi

                if [ -d          "$UPPM_PACKAGE_INSTALLED_DIR/share/aclocal" ] ; then
                    ACLOCAL_PATH="$UPPM_PACKAGE_INSTALLED_DIR/share/aclocal:$ACLOCAL_PATH"
                fi
            done
        fi

        export PATH
        export ACLOCAL_PATH
    }

    #########################################################################################

    [ -n "$PACKAGE_DEP_PYM" ] && {
        step "install needed python packages via pip3"

        run pip3 --version
        run pip3 install --upgrade pip setuptools wheel
        run pip3 --version

        for item in $PACKAGE_DEP_PYM
        do
            run pip3 install "$item" --upgrade
        done
    }

    [ -n "$PACKAGE_DEP_PLM" ] && {
        step "install needed perl modules via cpan"

        for item in $PACKAGE_DEP_PLM
        do
            if perl -M"$item" -le 'print "installed"' > /dev/null 2>&1 ; then
                note "perl module $item has been already installed."
            else
                case $item in
                    XML::Parser)
                        # https://metacpan.org/release/TODDR/XML-Parser-2.46/source/Makefile.PL#L8-9
                        export EXPATLIBPATH="$expat_LIBRARY_DIR"
                        export EXPATINCPATH="$expat_INCLUDE_DIR"
                        echo EXPATLIBPATH=$EXPATLIBPATH
                        echo EXPATINCPATH=$EXPATINCPATH
                        ;;
                esac

                # Would you like to configure as much as possible automatically? [yes]
                run "printf '%s\n' 'yes' | cpan $item"
            fi
        done

        if [ -d "$HOME/perl5/bin" ] ; then
            # cpan install to default local location
            bppend_to_PATH "$HOME/perl5/bin"
        fi
    }

    #########################################################################################

    [ "$PACKAGE_BUILD_SYSTEM_CARGO" = yes ] && {
        command -v rustup > /dev/null || {
            # https://www.rust-lang.org/tools/install
            note "${COLOR_GREEN}rustup cargo rustc${COLOR_OFF} ${COLOR_YELLOW}commands are required, but it is not found, let's install it.${COLOR_OFF}"

            if [ -f    "$XCPKG_HOME/tmp.d/rustup-init.sh" ] ; then
                run rm "$XCPKG_HOME/tmp.d/rustup-init.sh" || return 1
            fi

            wfetch 'https://sh.rustup.rs' --output-path="$XCPKG_HOME/tmp.d/rustup-init.sh" || return 1

            run bash "$XCPKG_HOME/tmp.d/rustup-init.sh" -y || return 1

            export CARGO_HOME="$HOME/.cargo"
            export PATH="$CARGO_HOME/bin:$PATH"
        }
    }

    #########################################################################################

    PACKAGE_INSTALL_DIR="$XCPKG_HOME/installed/$1"

    PACKAGE_WORKING_DIR="$XCPKG_HOME/installing/$1"

    PACKAGE_INSTALLING_SRC_DIR="$PACKAGE_WORKING_DIR/src"
    PACKAGE_INSTALLING_FIX_DIR="$PACKAGE_WORKING_DIR/fix"
    PACKAGE_INSTALLING_RES_DIR="$PACKAGE_WORKING_DIR/res"
    PACKAGE_INSTALLING_BIN_DIR="$PACKAGE_WORKING_DIR/bin"
    PACKAGE_INSTALLING_LIB_DIR="$PACKAGE_WORKING_DIR/lib"
    PACKAGE_INSTALLING_INC_DIR="$PACKAGE_WORKING_DIR/include"
    PACKAGE_INSTALLING_TMP_DIR="$PACKAGE_WORKING_DIR/tmp"

    PACKAGE_BCACHED_DIR="$PACKAGE_WORKING_DIR/src/build.d"

    if [ -z "$PACKAGE_BSCRIPT" ] ; then
        PACKAGE_BSCRIPT_DIR="$PACKAGE_INSTALLING_SRC_DIR"
    else
        PACKAGE_BSCRIPT_DIR="$PACKAGE_INSTALLING_SRC_DIR/$PACKAGE_BSCRIPT"
    fi

    #########################################################################################

    step "create relevant directories"

    rm -rf     "$PACKAGE_WORKING_DIR"

    install -d "$PACKAGE_BCACHED_DIR"

    install -d "$PACKAGE_INSTALLING_FIX_DIR"
    install -d "$PACKAGE_INSTALLING_RES_DIR"
    install -d "$PACKAGE_INSTALLING_BIN_DIR"
    install -d "$PACKAGE_INSTALLING_INC_DIR"
    install -d "$PACKAGE_INSTALLING_LIB_DIR"
    install -d "$PACKAGE_INSTALLING_TMP_DIR"

    #########################################################################################

    unset RECURSIVE_DEPENDENT_PACKAGES

    if [ -n "$PACKAGE_DEP_PKG" ] ; then
        step "generating dependency tree of $1"
        RECURSIVE_DEPENDENT_PACKAGES="$(__get_packages_that_are_recursively_depended_by_the_given_package $PACKAGE_NAME)"

        PACKAGE_DEPENDENCY_GRAPH_FILEPATH_DOT="$PACKAGE_WORKING_DIR/dependencies.dot"
        PACKAGE_DEPENDENCY_GRAPH_FILEPATH_BOX="$PACKAGE_WORKING_DIR/dependencies.box"
        PACKAGE_DEPENDENCY_GRAPH_FILEPATH_SVG="$PACKAGE_WORKING_DIR/dependencies.svg"
        PACKAGE_DEPENDENCY_GRAPH_FILEPATH_PNG="$PACKAGE_WORKING_DIR/dependencies.png"

        __gen_dependency_graph_recursively_depended_by_the_given_package "$PACKAGE_NAME" dot "$PACKAGE_DEPENDENCY_GRAPH_FILEPATH_DOT" || true
        __gen_dependency_graph_recursively_depended_by_the_given_package "$PACKAGE_NAME" box "$PACKAGE_DEPENDENCY_GRAPH_FILEPATH_BOX" || true
        # __gen_dependency_graph_recursively_depended_by_the_given_package "$PACKAGE_NAME" png "$PACKAGE_DEPENDENCY_GRAPH_FILEPATH_PNG" || true

        if [ -f "$PACKAGE_DEPENDENCY_GRAPH_FILEPATH_BOX" ] ; then
            cat "$PACKAGE_DEPENDENCY_GRAPH_FILEPATH_BOX"
        fi
    fi

    #########################################################################################

    step "fetch resources from server"
    __fetch_sources_of_the_given_package "$1"
    __fetch_patches_of_the_given_package "$1"

    #########################################################################################

    case $PACKAGE_SRC_FILETYPE in
        .dir)
            if [ "$PACKAGE_SRC_FILEPATH" = '/dev/null' ] ; then
                :
            elif [ -d "$PACKAGE_SRC_FILEPATH" ] ; then
                if [ -d "$PACKAGE_SRC_FILEPATH/.git" ] && command -v git > /dev/null ; then
                    PACKAGE_GIT_SHA=$(cd "$PACKAGE_SRC_FILEPATH" && git rev-parse HEAD || true)
                fi
                step "copy source files to the installing src directory"
                run cp -r "$PACKAGE_SRC_FILEPATH/." "$PACKAGE_INSTALLING_SRC_DIR"
            else
                die "src-url point to dir is not exist."
            fi
            ;;
        .git)
            if [ -z "$PACKAGE_GIT_SHA" ] ; then
                PACKAGE_GIT_SHA=$(cd "$PACKAGE_SRC_FILEPATH" && git rev-parse HEAD)
            fi
            step "copy source files to the installing src directory"
            run cp -r "$PACKAGE_SRC_FILEPATH/." "$PACKAGE_INSTALLING_SRC_DIR"
            ;;
        .zip)
            step "uncompressed source file to the installing src directory"
            run unzip  "$PACKAGE_SRC_FILEPATH" -d "$PACKAGE_INSTALLING_SRC_DIR"
            ;;
        .txz|.tgz|.tlz|.tbz2)
            step "uncompressed source file to the installing src directory"
            run tar xf "$PACKAGE_SRC_FILEPATH" -C "$PACKAGE_INSTALLING_SRC_DIR" --strip-components 1 --no-same-owner
            ;;
        *)  step "copy source files to the installing src directory"
            run cp     "$PACKAGE_SRC_FILEPATH"    "$PACKAGE_INSTALLING_SRC_DIR"
    esac

    if [ -n "$PACKAGE_FIX_FILETYPE" ] ; then
        case $PACKAGE_FIX_FILETYPE in
            .zip)
                step "uncompressed patch file to the installing fix directory"
                run unzip  "$PACKAGE_FIX_FILEPATH" -d "$PACKAGE_INSTALLING_FIX_DIR"
                ;;
            .txz|.tgz|.tlz|.tbz2)
                step "uncompressed patch file to the installing fix directory"
                run tar xf "$PACKAGE_FIX_FILEPATH" -C "$PACKAGE_INSTALLING_FIX_DIR" --strip-components 1 --no-same-owner
                ;;
            *)  step "copy patch file to the installing fix directory"
                run cp     "$PACKAGE_FIX_FILEPATH"    "$PACKAGE_INSTALLING_FIX_DIR"
        esac
    fi

    if [ -n "$PACKAGE_RES_FILETYPE" ] ; then
        case $PACKAGE_RES_FILETYPE in
            .zip)
                step "uncompressed res file to the installing res directory"
                run unzip "$PACKAGE_RES_FILEPATH" -d "$PACKAGE_INSTALLING_RES_DIR"
                ;;
            .txz|.tgz|.tlz|.tbz2)
                step "uncompressed res file to the installing res directory"
                run tar xf "$PACKAGE_RES_FILEPATH" -C "$PACKAGE_INSTALLING_RES_DIR" --strip-components 1 --no-same-owner
                ;;
            *)  step "copy res file to the installing res directory"
                run cp    "$PACKAGE_RES_FILEPATH"   "$PACKAGE_INSTALLING_RES_DIR"
        esac
    fi

    #########################################################################################

    step "tree files of the installing top directory"
    run tree --dirsfirst -L 2 "$PACKAGE_WORKING_DIR"

    step "list files of the installing src directory"
    run ls -l "$PACKAGE_INSTALLING_SRC_DIR"

    if [ -n "$PACKAGE_BSCRIPT" ] ; then
        step "list files of the installing build script directory"
        run ls -l "$PACKAGE_BSCRIPT_DIR"
    fi

    #########################################################################################

    step "build for native"

    unset NATIVE_BCACHED_DIR
    unset NATIVE_INSTALL_DIR

    if command -v build0 > /dev/null ; then
        NATIVE_BCACHED_DIR="$PACKAGE_WORKING_DIR/native"
        NATIVE_INSTALL_DIR="$XCPKG_HOME/native/$PACKAGE_NAME"

        if [ -f "$NATIVE_INSTALL_DIR/version.txt" ] ; then
            if [ "$(cat "$NATIVE_INSTALL_DIR/version.txt")" != "$PACKAGE_VERSION" ] ; then
                warn "build for native already have been done, but not same version. we will remove and rebuild it."
                run rm -rf "$NATIVE_INSTALL_DIR"
            fi
        fi

        if [ -f "$NATIVE_INSTALL_DIR/version.txt" ] ; then
            note "build for native already have been done, skipped."
        else
            [ "$PACKAGE_BUILD_IN_BSCRIPT_DIR" = yes ] || {
                run install -d "$NATIVE_BCACHED_DIR" || return 1
                run cd         "$NATIVE_BCACHED_DIR" || return 1
            }

            for TOOL in PKG_CONFIG MESON CMAKE GMAKE NINJA
            do
                printf "%19s = %s\n" "$TOOL" "$(eval echo \$$TOOL)"
            done

            echo

            for TOOL in CC CXX CPP AS AR RANLIB LD NM STRIP SIZE STRINGS OBJDUMP
            do
                eval export "$TOOL=\"\$${TOOL}_FOR_BUILD\""
                printf "%19s = %s\n" "$TOOL" "$(eval echo \$$TOOL)"
            done

            for FLAG in CFLAGS CXXFLAGS CPPFLAGS LDFLAGS
            do
                eval export "$FLAG=\"\$${FLAG}_FOR_BUILD\""
                printf "\n%19s = " "$FLAG"
                FIRST=yes
                for item in $(eval echo \$$FLAG | tr ':' ' ')
                do
                    if [ "$FIRST" = yes ] ; then
                        FIRST=no
                        echo "$item"
                    else
                        echo "                      $item"
                    fi
                done
            done
            echo
            printf "\n%19s = " PATH
            FIRST=yes
            for item in $(printf '%s\n' "$PATH" | tr ' ' '|' | tr ':' ' ')
            do
                if [ "$FIRST" = yes ] ; then
                    FIRST=no
                    printf '%s\n' "$item" | tr '|' ' '
                else
                    printf '%s\n' "                      $item" | tr '|' ' '
                fi
            done

            cat <<EOF

        BUILD_NJOBS = $BUILD_NJOBS

PACKAGE_WORKING_DIR = $PACKAGE_WORKING_DIR
PACKAGE_BSCRIPT_DIR = $PACKAGE_BSCRIPT_DIR

 NATIVE_BCACHED_DIR = $NATIVE_BCACHED_DIR
 NATIVE_INSTALL_DIR = $NATIVE_INSTALL_DIR

                PWD = $PWD

EOF

            run build0 || return 1

            echo "$PACKAGE_VERSION" > "$NATIVE_INSTALL_DIR/version.txt"

            if [ -d "$NATIVE_INSTALL_DIR/bin" ] ; then
                export PATH="$NATIVE_INSTALL_DIR/bin:$PATH"
            fi
        fi
    else
        note "no build0  mapping not found in formula, skipped."
    fi

    #########################################################################################

    step "config variables for ${COLOR_GREEN}$@${COLOR_OFF}"
    __config_variables_for_the_given_target $@

    step "printf variables for ${COLOR_GREEN}$@${COLOR_OFF}"
    __printf_variables_for_the_given_target $@

    #########################################################################################

    if [ "$CCACHE_ENABLED" = yes ] ; then
        ccache -s > "$PACKAGE_WORKING_DIR/ccache-s.txt"
    fi

    #########################################################################################

    step "create symbolic links for dependent libs"

    if [ -z "$RECURSIVE_DEPENDENT_PACKAGES" ] ; then
        note "no dependent libs, skipped."
    else
        case $LINK_TYPE in
            static-only|static-prefered) LINK_LIBRARY_TYPE=a  ;;
            shared-only|shared-prefered) LINK_LIBRARY_TYPE=dylib ;;
        esac

        for DEPENDENT_PACKAGE_NAME in $RECURSIVE_DEPENDENT_PACKAGES
        do
            DEPENDENT_PACKAGE_LIBRARY_DIR="$XCPKG_PACKAGE_INSTALLED_ROOT/$TARGET_PLATFORM_NAME/$TARGET_PLATFORM_VERS/$TARGET_PLATFORM_ARCH/$DEPENDENT_PACKAGE_NAME/lib"

            if [ -d "$DEPENDENT_PACKAGE_LIBRARY_DIR" ] ; then
                for item in $(find "$DEPENDENT_PACKAGE_LIBRARY_DIR" -maxdepth 1 -mindepth 1 -name "lib*.$LINK_LIBRARY_TYPE" -exec basename {} \;)
                do
                    if [ ! -e "$PACKAGE_INSTALLING_LIB_DIR/$item" ] ; then
                        run ln -s "$DEPENDENT_PACKAGE_LIBRARY_DIR/$item" "$PACKAGE_INSTALLING_LIB_DIR/$item"
                    fi
                done
            fi
        done

        unset LINK_LIBRARY_TYPE
    fi

    #########################################################################################

    step "do some preparation works"

    if [ "$PWD" != "$PACKAGE_BSCRIPT_DIR" ] ; then
        run cd "$PACKAGE_BSCRIPT_DIR"
    fi

    if [ -n "$PACKAGE_PREPARE_ACTIONS" ] ; then
        cat > "$PACKAGE_INSTALLING_TMP_DIR/prepare.sh" <<EOF
prepare() {
$PACKAGE_PREPARE_ACTIONS
}
EOF
        . "$PACKAGE_INSTALLING_TMP_DIR/prepare.sh"
        prepare "$1" || return 1
    else
        case $PACKAGE_BUILD_SYSTEM in
            autogen)
                note "prepare mapping not found in formula."
                run NOCONFIGURE=yes ./autogen.sh    || return 1
                ;;
            autotools)
                note "prepare mapping not found in formula."
                run autoreconf -ivf || return 1
                ;;
            *)  note "prepare mapping not found in formula, skipped."
        esac
    fi

    #########################################################################################

    step "create symbolic link for CC and CXX to use ccache"

    if [ "$CCACHE_ENABLED" = yes ] ; then
        run ln -s "$CCACHE" "$PACKAGE_WORKING_DIR/bin/clang"
        run ln -s "$CCACHE" "$PACKAGE_WORKING_DIR/bin/clang++"
        run export CC="$PACKAGE_WORKING_DIR/bin/clang"
        run export CXX="$PACKAGE_WORKING_DIR/bin/clang++"
        run export CPP="'$CC -E'"
        run export PATH="'$PACKAGE_WORKING_DIR/bin:$PATH'"
    else
        note "ccache is disabled, skipped."
    fi

    #########################################################################################

    [ "$PACKAGE_BUILD_SYSTEM_CMAKE" = yes ] && {
        step "create cmake toolchain file for ${COLOR_GREEN}$@${COLOR_OFF}"
        __create_cmake_toolchain_file_for_the_given_target $@ || return 1
    }

    #########################################################################################

    [ "$DRYRUN" = yes ] && {
        [ -z "$SHELL" ] && SHELL=$(command -v zsh || command -v bash || command -v sh)
        [ -z "$SHELL" ] && SHELL=sh
        exec "$SHELL" || return 1
    }

    #########################################################################################

    step "building"

    if [ "$PACKAGE_BUILD_IN_BSCRIPT_DIR" = yes ] ; then
        if [ "$PWD" != "$PACKAGE_BSCRIPT_DIR" ] ; then
            run cd "$PACKAGE_BSCRIPT_DIR" || return 1
        fi
    else
            run cd "$PACKAGE_BCACHED_DIR" || return 1
    fi

    if [ -d "$PACKAGE_INSTALL_DIR" ] ; then
        run rm -rf "$PACKAGE_INSTALL_DIR" || return 1
    fi

    if [ -n "$PACKAGE_INSTALL_ACTIONS" ] ; then
        cat > "$PACKAGE_INSTALLING_TMP_DIR/install.sh" <<EOF
build() {
$PACKAGE_INSTALL_ACTIONS
}
EOF
        . "$PACKAGE_INSTALLING_TMP_DIR/install.sh"

        build "$1"
    else
        case $PACKAGE_BUILD_SYSTEM in
            autogen)   configure ;;
            autotools) configure ;;
            configure) configure ;;
            cmake*)    cmakew ;;
            meson)     mesonw ;;
            ninja)     ninjaw clean && ninjaw && ninjaw install ;;
            gmake)     gmakew clean && gmakew && gmakew install ;;
            cargo)     cargow install ;;
            go)        gow ;;
        esac
    fi

    #########################################################################################

    [ "$PACKAGE_BUILD_SYSTEM_CARGO" = yes ] && {
        rm -f "$PACKAGE_INSTALL_DIR/.crates.toml"
        rm -f "$PACKAGE_INSTALL_DIR/.crates2.json"
    }

    #########################################################################################

    cd "$PACKAGE_INSTALL_DIR" || die "nothing is installed."

    [ -z "$(ls)" ]            && die "nothing is installed."

    #########################################################################################

    PACKAGE_METAINF_DIR="$PACKAGE_INSTALL_DIR/.xcpkg"

    PACKAGE_MANIFEST_FILEPATH="$PACKAGE_METAINF_DIR/manifest.txt"
    PACKAGE_RECEIPT_FILEPATH="$PACKAGE_METAINF_DIR/receipt.yml"

    install -d "$PACKAGE_METAINF_DIR"

    #########################################################################################

    step "install config.log"

    for dir in "$PACKAGE_BCACHED_DIR" "$PACKAGE_BSCRIPT_DIR"
    do
        if [ -f "$dir/config.log" ] ; then
            install -v -m 644 "$dir/config.log" "$PACKAGE_METAINF_DIR"
        fi
    done

    #########################################################################################

    step "install compile_commands.json"

    for dir in "$PACKAGE_BCACHED_DIR" "$PACKAGE_BSCRIPT_DIR"
    do
        if [ -f "$dir/compile_commands.json" ] ; then
            install -v -m 644 "$dir/compile_commands.json" "$PACKAGE_METAINF_DIR"
        fi
    done

    #########################################################################################

    step "install dependencies.dot and dependencies.txt"

    for file in $PACKAGE_DEPENDENCY_GRAPH_FILEPATH_DOT $PACKAGE_DEPENDENCY_GRAPH_FILEPATH_BOX $PACKAGE_DEPENDENCY_GRAPH_FILEPATH_SVG $PACKAGE_DEPENDENCY_GRAPH_FILEPATH_PNG
    do
        if [ -f "$file" ] ; then
            install -v -m 644 "$file" "$PACKAGE_METAINF_DIR"
        fi
    done

    #########################################################################################

    step "adjust Mach-O files for ${COLOR_GREEN}$@${COLOR_OFF}"
    __adjust_mach_o_files_for_the_given_target $@

    if [ -d "$PACKAGE_INSTALL_DIR/lib" ] ; then
        step "adjust .la files for ${COLOR_GREEN}$@${COLOR_OFF}"
        __adjust_la_files_for_the_given_target $@

        step "adjust .pc files for ${COLOR_GREEN}$@${COLOR_OFF}"
        __adjust_pc_files_for_the_given_target $@
    fi

    #########################################################################################

    step "generate buildon.yml"
    cat > "$PACKAGE_METAINF_DIR/buildon.yml" <<EOF
os-kind: $NATIVE_OS_KIND
os-type: $NATIVE_OS_TYPE
os-arch: $NATIVE_OS_ARCH
os-vers: $NATIVE_OS_VERS
os-ncpu: $NATIVE_OS_NCPU
os-euid: $NATIVE_OS_EUID
os-egid: $NATIVE_OS_EGID
EOF

    step "generate manifest.txt"
    __generate_manifest_of_the_given_package "$1"

    step "generate receipt.yml"
    __generate_receipt_of_the_given_package "$1"

    if [ "$PACKAGE_SYMLINK" = yes ] ; then
        step "symlink installed files to $XCPKG_PACKAGE_SYMLINKED_ROOT"
        __symlink_installed_files_of_the_given_package "$1"
    fi

    #########################################################################################

    [ "$CCACHE_ENABLED" = yes ] && {
        step "show ccache statistics summary"
        info "Before Build:"
        run  cat "$PACKAGE_WORKING_DIR/ccache-s.txt"
        info "After  Build:"
        run  ccache -s
    }

    [ "$KEEP_WORKING_DIR" = yes ] || {
        step "delete the installing directory."
        run rm -rf "$PACKAGE_WORKING_DIR"
    }

    echo
    success "$1 have been successfully installed."

    step "show installed files in tree-like format"
    __tree_the_given_installed_package "$1" -a --dirsfirst
}

__adjust_mach_o_files_for_the_given_target() {
    unset BASE64_COMMAND; export BASE64_COMMAND="$(command -v base64)"

    BASE64_ENCODE_STRING_COMMAND="$XCPKG_CORE_BIN_DIR/base64-encode-string"

    for x in bin sbin lib libexec
    do
        [ -d "$PACKAGE_INSTALL_DIR/$x" ] || continue

        for BASE64_ENCODED_RELATIVE_FILEPATH in $(cd "$PACKAGE_INSTALL_DIR/$x" && find . -not -name . -type f -exec $BASE64_ENCODE_STRING_COMMAND {} \;)
        do
            unset BASE64_DECODED_RELATIVE_FILEPATH
            BASE64_DECODED_RELATIVE_FILEPATH="$(printf '%s\n' "$BASE64_ENCODED_RELATIVE_FILEPATH" | base64 -d)"

            FILEPATH="$PACKAGE_INSTALL_DIR/$x/${BASE64_DECODED_RELATIVE_FILEPATH#./}"

            unset FILE_HEADER_ACTUAL
            FILE_HEADER_ACTUAL="$(hexdump -n 16 -v -e '1/1 "%02X" ""' "$FILEPATH")"

            # https://github.com/aidansteele/osx-abi-macho-file-format-reference
            case $FILE_HEADER_ACTUAL in
                CFFAEDFE0C000001000000000[26]000000)
                    # arm64
                    ;;
                CFFAEDFE07000001030000000[26]000000)
                    # x86_64
                    ;;
                *)  continue
            esac

            unset DT_SONAME
            DT_SONAME=$( otool -l "$FILEPATH" | grep LC_ID_DYLIB   -A2 | grep name | sed 's|^[[:space:]]*||' | cut -d ' ' -f2)

            unset DT_NEEDED
            DT_NEEDED=$( otool -l "$FILEPATH" | grep LC_LOAD_DYLIB -A2 | grep name | sed 's|^[[:space:]]*||' | cut -d ' ' -f2)

            unset DT_RUNPATH
            DT_RUNPATH=$(otool -l "$FILEPATH" | grep LC_RPATH      -A2 | grep path | sed 's|^[[:space:]]*||' | cut -d ' ' -f2)

            if [ -z "$DT_NEEDED" ] ; then
                die "no dependent shared libraries found in $FILEPATH"
            fi

            echo "DT_SONAME=\n$DT_SONAME"
            echo "DT_NEEDED=\n$DT_NEEDED"
            echo "DT_RUNPATH=\n$DT_RUNPATH"

            case $DT_SONAME in
                '') ;;
                @*) ;;
                /*) ;;
                lib*.dylib) run install_name_tool -id "@rpath/$DT_SONAME" "$FILEPATH"
            esac

            for NEEDED in $DT_NEEDED
            do
                case $NEEDED in
                    lib*.dylib)
                        run install_name_tool -change "$NEEDED" "@rpath/$NEEDED" "$FILEPATH"
                esac
            done

            if [ "$BUILD_TYPE" = release ] ; then
                if [ "$x" != lib ] ; then
                    run "$STRIP" $STRIP_ARG "$FILEPATH" || true
                fi
            fi
        done
    done
}

__adjust_la_files_for_the_given_target() {
    [ -d "$PACKAGE_INSTALL_DIR/lib" ] || {
        note "no .la files installed, skipped"
        return 0
    }

    LA_FILES="$(find "$PACKAGE_INSTALL_DIR/lib" -name "*.la")"

    [ -z "$LA_FILES" ] && {
        note "no .la files installed, skipped"
        return 0
    }

    for lafile in $LA_FILES
    do
        sed_in_place 's|-Wl,--strip-debug||g'      "$lafile"
        sed_in_place "s|-L$XCPKG_HOME[^' ]*||g"    "$lafile"
        sed_in_place "s|-R[^' ]*||g"               "$lafile"
        #sed_in_place "s|-L$SYSTEM_LIBRARY_DIR||g"  "$lafile"
        #sed_in_place "s|--sysroot $SYSROOT||g"     "$lafile"
    done
}

__adjust_pc_files_for_the_given_target() {
    [ -d "$PACKAGE_INSTALL_DIR/lib/pkgconfig" ] || {
        note "no .pc files installed, skipped"
        return 0
    }

    PC_FILES="$(find "$PACKAGE_INSTALL_DIR/lib/pkgconfig" -name "*.pc")"

    [ -z "$PC_FILES" ] && {
        note "no .pc files installed, skipped"
        return 0
    }

    # cc: error: unrecognized command line option â€˜-Râ€™
    for pcfile in $PC_FILES
    do
        sed_in_place "s|$PACKAGE_INSTALL_DIR|\${pcfiledir}/../..|g" "$pcfile"
        sed_in_place 's|-Wl,--strip-debug||g'      "$pcfile"
        sed_in_place "s|-L$XCPKG_HOME[^' ]*||g"    "$pcfile"
        sed_in_place "s|-R[^' ]*||g"               "$pcfile"
        #sed_in_place "s|-L$SYSTEM_LIBRARY_DIR||g"  "$pcfile"
        #sed_in_place "s|--sysroot $SYSROOT||"      "$pcfile"

        if grep 'Libs.private:' "$pcfile" > /dev/null ; then
            if grep 'Libs:' "$pcfile" > /dev/null ; then
                LIBS_PRIVATE_CONTENT=$(sed -n '/Libs.private:/p' "$pcfile" | cut -c14-)
                sed_in_place "/Libs:/s|\$|$LIBS_PRIVATE_CONTENT|" "$pcfile"
                sed_in_place '/Libs.private:/d' "$pcfile"
            else
                sed_in_place 's|Libs.private:|Libs:|' "$pcfile"
            fi
        fi

        if grep 'Requires.private:' "$pcfile" > /dev/null ; then
            if grep 'Requires:' "$pcfile" > /dev/null ; then
                REQUIRES_PRIVATE_CONTENT=$(sed -n '/Requires.private:/p' "$pcfile" | cut -c18-)
                sed_in_place "/Requires:/s|\$|$REQUIRES_PRIVATE_CONTENT|" "$pcfile"
                sed_in_place '/Requires.private:/d' "$pcfile"
            else
                sed_in_place 's|Requires.private:|Requires:|' "$pcfile"
            fi
        fi
    done
}


__install_pc_file_if_needed_for_the_given_target() {
    if [ -d "$PACKAGE_INSTALL_DIR/lib" ] ; then
        if [ ! -d "$PACKAGE_INSTALL_DIR/lib/pkgconfig" ] ; then
            cat > "$PACKAGE_BCACHED_DIR/$1.pc" << EOF
EOF
            run install_pcfs "$PACKAGE_BCACHED_DIR/$1.pc"
        fi
    fi
}

install_incs() {
    while [ -n "$1" ]
    do
        unset X1
        unset X2
        X1=$(echo "$1" | cut -d: -f1)
        X2=$(echo "$1" | cut -d: -f2)

        if [ "$X1" = "$X2" ] ; then
            unset X2
        fi

        install -v -d         "$PACKAGE_INSTALL_DIR/include/$X2" || return 1
        install -v -m 644 $X1 "$PACKAGE_INSTALL_DIR/include/$X2" || return 1

        shift
    done
}

install_libs() {
    install -v -d "$PACKAGE_INSTALL_DIR/lib" || return 1
    for item in $@
    do
        case $item in
            *.a) install -v -m 644 $item "$PACKAGE_INSTALL_DIR/lib" || return 1 ;;
            *)   install -v -m 755 $item "$PACKAGE_INSTALL_DIR/lib" || return 1 ;;
        esac
    done
}

install_pcfs() {
    install -v -d        "$PACKAGE_INSTALL_DIR/lib/pkgconfig" &&
    install -v -m 644 $@ "$PACKAGE_INSTALL_DIR/lib/pkgconfig"
}

install_bins() {
    install -v -d        "$PACKAGE_INSTALL_DIR/bin" &&
    install -v -m 755 $@ "$PACKAGE_INSTALL_DIR/bin"
}

install_etcs() {
    install -v -d        "$PACKAGE_INSTALL_DIR/etc" &&
    install -v -m 644 $@ "$PACKAGE_INSTALL_DIR/etc"
}

install_mans() {
    for item in $@
    do
        unset NUMBER
        NUMBER=$(echo "$item" | cut -c ${#item}-${#item})
        case $NUMBER in
            [1-8]);;
            *)    die "$item: not a manpage."
        esac
        install -v -d           "$PACKAGE_INSTALL_DIR/share/man/man$NUMBER" &&
        install -v -m 644 $item "$PACKAGE_INSTALL_DIR/share/man/man$NUMBER"
    done
}

# install_completion <fish|bash|zsh> <COMMAND> <FILE-PATH>
  install_completion() {
    case $1 in
        bash)
            install -v -d          "$PACKAGE_INSTALL_DIR/share/bash/completions" &&
            install -v -m 644 "$3" "$PACKAGE_INSTALL_DIR/share/bash/completions/$2"
            ;;
        fish)
            install -v -d          "$PACKAGE_INSTALL_DIR/share/fish/vendor_completions.d" &&
            install -v -m 644 "$3" "$PACKAGE_INSTALL_DIR/share/fish/vendor_completions.d/$2.fish"
            ;;
        zsh)
            install -v -d          "$PACKAGE_INSTALL_DIR/share/zsh/site-functions" &&
            install -v -m 644 "$3" "$PACKAGE_INSTALL_DIR/share/zsh/site-functions/_$2"
            ;;
        *)  die "install_completion unsupported shell: $1"
    esac
}

install_pc_file() {
    install -v -d "$PACKAGE_INSTALL_DIR/lib/pkgconfig" &&
    cat >         "$PACKAGE_INSTALL_DIR/lib/pkgconfig/$1.pc"
}

# __show_information_of_all_available_packages [--json|--yaml|--shell]
  __show_information_of_all_available_packages() {
    case $1 in
        --json) __show_information_as_json__of_all_available_packages ;;
        --yaml) __show_information_as_yaml__of_all_available_packages ;;
        --shell)__show_information_as_shell_of_all_available_packages ;;
        '')     __show_information_as_mixed_of_all_available_packages ;;
        *)    die "__show_information_of_all_available_packages [--json|--yaml|--shell], unrecognized option: $1"
    esac
}

__show_information_as_mixed_of_all_available_packages() {
    FIRST=yes

    for PACKAGE in $(__list_available_packages)
    do
        if [ "$FIRST" = yes ] ; then
            FIRST=no
        else
            printf '%s\n' '========'
        fi
        __show_information_of_the_given_package "$PACKAGE"
    done
}

__show_information_as_json__of_all_available_packages() {
    printf '%s\n' '['

    FIRST=yes

    for PACKAGE in $(__list_available_packages)
    do
        if [ "$FIRST" = yes ] ; then
            FIRST=no
        else
            printf '%s\n' ','
        fi
        __show_information_as_json__of_the_given_package "$PACKAGE"
    done

    printf '%s\n' ']'
}

__show_information_as_yaml__of_all_available_packages() {
    FIRST=yes

    for PACKAGE in $(__list_available_packages)
    do
        if [ "$FIRST" = yes ] ; then
            FIRST=no
        else
            printf '%s\n' '---'
        fi
        __show_information_as_yaml__of_the_given_package "$PACKAGE"
    done
}

__show_information_as_shell_of_all_available_packages() {
    FIRST=yes

    for PACKAGE in $(__list_available_packages)
    do
        if [ "$FIRST" = yes ] ; then
            FIRST=no
        else
            printf '%s\n' '#---'
        fi
        __show_information_as_shell_of_the_given_package "$PACKAGE"
    done
}

# __show_information_as_json__of_the_given_package <PACKAGE-NAME>
  __show_information_as_json__of_the_given_package() {
    __load_formula_of_the_given_package "$1"

    if [ -z "$PACKAGE_WEB_URL" ] ; then
        PACKAGE_WEB_URL="$PACKAGE_GIT_URL"
    fi

    jq  --null-input \
        --arg pkgname "$PACKAGE_NAME" \
        --arg version "$PACKAGE_VERSION" \
        --arg summary "$PACKAGE_SUMMARY" \
        --arg license "$PACKAGE_LICENSE" \
        --arg web_url "$PACKAGE_WEB_URL" \
        --arg git_url "$PACKAGE_GIT_URL" \
        --arg git_sha "$PACKAGE_GIT_SHA" \
        --arg git_ref "$PACKAGE_GIT_REF" \
        --arg src_url "$PACKAGE_SRC_URL" \
        --arg src_sha "$PACKAGE_SRC_SHA" \
        --arg fix_url "$PACKAGE_FIX_URL" \
        --arg fix_sha "$PACKAGE_FIX_SHA" \
        --arg res_url "$PACKAGE_RES_URL" \
        --arg res_sha "$PACKAGE_RES_SHA" \
        --arg dep_pkg "$PACKAGE_DEP_PKG" \
        --arg dep_upp "$PACKAGE_DEP_UPP" \
        --arg dep_pym "$PACKAGE_DEP_PYM" \
        --arg dep_plm "$PACKAGE_DEP_PLM" \
        --arg prepare "$PACKAGE_PREPARE_ACTIONS" \
        --arg install "$PACKAGE_INSTALL_ACTIONS" \
        --arg bsystem "$PACKAGE_BSYSTEM" \
        --arg binbstd "$PACKAGE_BINBSTD" \
        --arg cdefine "$PACKAGE_CDEFINE" \
        --arg ccflags "$PACKAGE_CCFLAGS" \
        --arg xxflags "$PACKAGE_XXFLAGS" \
        --arg ldflags "$PACKAGE_LDFLAGS" \
        --arg parallel $PACKAGE_BUILD_IN_PARALLEL \
'{
    "pkgname":$pkgname,
    "version":$version,
    "license":$license,
    "summary":$summary,
    "web-url":$web_url,
    "git-url":$git_url,
    "git-sha":$git_sha,
    "git-ref":$git_ref,
    "src-url":$src_url,
    "src-sha":$src_sha,
    "fix-url":$fix_url,
    "fix-sha":$fix_sha,
    "res-url":$res_url,
    "res-sha":$res_sha,
    "dep-pkg":$dep_pkg,
    "dep-upp":$dep_upp,
    "dep-pym":$dep_pym,
    "dep-plm":$dep_plm,
    "bsystem":$bsystem,
    "binbstd":$binbstd,
    "cdefine":$cdefine,
    "ccflags":$ccflags,
    "xxflags":$xxflags,
    "ldflags":$ldflags,
    "parallel":$parallel,
    "prepare":$prepare,
    "install":$install
}' | jq 'with_entries(select(.value != ""))'
}

# __show_information_as_yaml__of_the_given_package <PACKAGE-NAME>
  __show_information_as_yaml__of_the_given_package() {
    __view_formula_of_the_given_package "$1" --paging=never
}

# __show_information_as_shell_of_the_given_package <PACKAGE-NAME>
  __show_information_as_shell_of_the_given_package() {
    __load_formula_of_the_given_package "$1"

    while read KEY
    do
        printf "%s='%s'\n" "${PACKAGE_NAME_UPPERCASE_UNDERSCORE}_${KEY}" "$(eval echo \$$KEY)"
    done <<EOF
PACKAGE_NAME
PACKAGE_SUMMARY
PACKAGE_WEB_URL
PACKAGE_GIT_URL
PACKAGE_GIT_SHA
PACKAGE_GIT_REF
PACKAGE_SVN_URL
PACKAGE_SRC_URL
PACKAGE_SRC_SHA
PACKAGE_SRC_FILETYPE
PACKAGE_SRC_FILENAME
PACKAGE_SRC_FILEPATH
PACKAGE_FIX_URL
PACKAGE_FIX_SHA
PACKAGE_FIX_FILETYPE
PACKAGE_FIX_FILENAME
PACKAGE_FIX_FILEPATH
PACKAGE_VERSION
PACKAGE_VERSION_MAJOR
PACKAGE_VERSION_MINOR
PACKAGE_VERSION_PATCH
PACKAGE_VERSION_TWEAK
PACKAGE_DEVELOPER
PACKAGE_LICENSE
PACKAGE_BSCRIPT
PACKAGE_BSYSTEM
PACKAGE_BINBSTD
PACKAGE_BUILD_SYSTEM
PACKAGE_BUILD_SYSTEM_GO
PACKAGE_BUILD_SYSTEM_RAKE
PACKAGE_BUILD_SYSTEM_NINJA
PACKAGE_BUILD_SYSTEM_GMAKE
PACKAGE_BUILD_SYSTEM_CMAKE
PACKAGE_BUILD_SYSTEM_XMAKE
PACKAGE_BUILD_SYSTEM_MESON
PACKAGE_BUILD_SYSTEM_CARGO
PACKAGE_BUILD_SYSTEM_AUTOGENSH
PACKAGE_BUILD_SYSTEM_AUTOTOOLS
PACKAGE_BUILD_SYSTEM_CONFIGURE
PACKAGE_BUILD_IN_BSCRIPT_DIR
PACKAGE_BUILD_IN_PARALLEL
PACKAGE_DEP_PKG
PACKAGE_CDEFINE
PACKAGE_CCFLAGS
PACKAGE_XXFLAGS
PACKAGE_LDFLAGS
PACKAGE_FORMULA_FILEPATH
EOF
}

# __show_information_of_the_given_package <PACKAGE-NAME> [OPTIONS]
#
# __show_information_of_the_given_package curl
#
# __show_information_of_the_given_package curl version
# __show_information_of_the_given_package curl web-url
  __show_information_of_the_given_package() {
    [ -z "$1" ] && {
        error "__show_information_of_the_given_package <PACKAGE-NAME> [ARGUMENTS], <PACKAGE-NAME> is unspecified."
        return 1
    }

    case $1 in
        @all) shift ; __show_information_of_all_available_packages $@ ; return $?
    esac

    case $2 in
        formula-yaml|'')
            __show_information_as_yaml__of_the_given_package "$1"
            ;;
        formula-json)
            __show_information_as_json__of_the_given_package "$1"
            ;;
        formula-path)
            __path_of_formula_of_the_given_package "$1"
            ;;
        receipt-yaml)
            if is_package_installed "$1" ; then
                cat "$XCPKG_PACKAGE_INSTALLED_ROOT/$1/.xcpkg/receipt.yml"
            else
                error "package [$1] is not installed."
                return 1
            fi
            ;;
        receipt-json)
            __load_receipt_of_the_given_package "$1"

            jq  --null-input \
                --arg pkgname "$1" \
                --arg version "$RECEIPT_PACKAGE_VERSION" \
                --arg summary "$RECEIPT_PACKAGE_SUMMARY" \
                --arg license "$RECEIPT_PACKAGE_LICENSE" \
                --arg web_url "$RECEIPT_PACKAGE_WEB_URL" \
                --arg git_url "$RECEIPT_PACKAGE_GIT_URL" \
                --arg git_sha "$RECEIPT_PACKAGE_GIT_SHA" \
                --arg git_ref "$RECEIPT_PACKAGE_GIT_REF" \
                --arg src_url "$RECEIPT_PACKAGE_SRC_URL" \
                --arg src_sha "$RECEIPT_PACKAGE_SRC_SHA" \
                --arg fix_url "$RECEIPT_PACKAGE_FIX_URL" \
                --arg fix_sha "$RECEIPT_PACKAGE_FIX_SHA" \
                --arg res_url "$RECEIPT_PACKAGE_RES_URL" \
                --arg res_sha "$RECEIPT_PACKAGE_RES_SHA" \
                --arg dep_pkg "$RECEIPT_PACKAGE_DEP_PKG" \
                --arg dep_upp "$RECEIPT_PACKAGE_DEP_UPP" \
                --arg dep_pym "$RECEIPT_PACKAGE_DEP_PYM" \
                --arg dep_plm "$RECEIPT_PACKAGE_DEP_PLM" \
                --arg cdefine "$RECEIPT_PACKAGE_CDEFINE" \
                --arg ccflags "$RECEIPT_PACKAGE_CCFLAGS" \
                --arg xxflags "$RECEIPT_PACKAGE_XXFLAGS" \
                --arg ldflags "$RECEIPT_PACKAGE_LDFLAGS" \
                --arg bsystem "$RECEIPT_PACKAGE_BSYSTEM" \
                --arg binbstd "$RECEIPT_PACKAGE_BINBSTD" \
                --arg parallel "$RECEIPT_PACKAGE_PARALLEL" \
                --arg signature "$PACKAGE_RECEIPT_SIGNATURE" \
                --arg timestamp "$PACKAGE_RECEIPT_TIMESTAMP" \
'{
    "pkgname":$pkgname,
    "version":$version,
    "license":$license,
    "summary":$summary,
    "web-url":$web_url,
    "git-url":$git_url,
    "git-sha":$git_sha,
    "git-ref":$git_ref,
    "src-url":$src_url,
    "src-sha":$src_sha,
    "fix-url":$fix_url,
    "fix-sha":$fix_sha,
    "res-url":$res_url,
    "res-sha":$res_sha,
    "dep-pkg":$dep_pkg,
    "dep-upp":$dep_upp,
    "dep-pym":$dep_pym,
    "dep-plm":$dep_plm,
    "bsystem":$bsystem,
    "binbstd":$binbstd,
    "cdefine":$cdefine,
    "ccflags":$ccflags,
    "xxflags":$xxflags,
    "ldflags":$ldflags,
    "parallel":$parallel,
    "signature":$signature,
    "timestamp":$timestamp,
}' | jq 'with_entries(select(.value != ""))'

            ;;
        receipt-path)
            if is_package_installed "$1" ; then
                printf '%s\n' "$XCPKG_PACKAGE_INSTALLED_ROOT/$1/.xcpkg/receipt.yml"
            else
                error "package [$1] is not installed."
                return 1
            fi
            ;;
        symlinked-files)
            if [ -f "$XCPKG_PACKAGE_SYMLINKED_ROOT/.registry/$1" ] ; then
                cat "$XCPKG_PACKAGE_SYMLINKED_ROOT/.registry/$1"
            fi
            ;;
        installed-dir)
            if is_package_installed "$1" ; then
                printf '%s\n' "$XCPKG_PACKAGE_INSTALLED_ROOT/$1"
            else
                error "package [$1] is not installed."
                return 1
            fi
            ;;
        installed-files)
            if is_package_installed "$1" ; then
                cut -d '|' -f3 "$XCPKG_PACKAGE_INSTALLED_ROOT/$1/.xcpkg/manifest.txt"
            else
                error "package [$1] is not installed."
                return 1
            fi
            ;;
        installed-timestamp-unix)
            __load_receipt_of_the_given_package "$1"
            printf '%s\n' "$PACKAGE_RECEIPT_TIMESTAMP"
            ;;
        installed-timestamp-rfc-3339)
            __load_receipt_of_the_given_package "$1"
            format_unix_timestamp "$PACKAGE_RECEIPT_TIMESTAMP" '+%Y-%m-%d %H:%M:%S%:z'
            ;;
        installed-timestamp-iso-8601)
            __load_receipt_of_the_given_package "$1"
            format_unix_timestamp "$PACKAGE_RECEIPT_TIMESTAMP" '+%Y-%m-%dT%H:%M:%S%:z'
            ;;
        installed-timestamp-rfc-3339-utc)
            __load_receipt_of_the_given_package "$1"
            format_unix_timestamp "$PACKAGE_RECEIPT_TIMESTAMP" '+%Y-%m-%d %H:%M:%S%:z' -u
            ;;
        installed-timestamp-iso-8601-utc)
            __load_receipt_of_the_given_package "$1"
            format_unix_timestamp "$PACKAGE_RECEIPT_TIMESTAMP" '+%Y-%m-%dT%H:%M:%SZ' -u
            ;;
        installed-version)
            __load_receipt_of_the_given_package "$1"
            printf '%s\n' "$RECEIPT_PACKAGE_VERSION"
            ;;
        *)  __load_formula_of_the_given_package "$1"
            __PACKAGE_GET__KEY__="$(printf '%s\n' "$2" | tr '+-.' '_' | tr a-z A-Z)"
            eval echo \$PACKAGE_$__PACKAGE_GET__KEY__
    esac
}

mark_is_package_installed_or_not() {
    if is_package_installed "$1" ; then
        echo "${COLOR_GREEN}$1${COLOR_OFF}"
    else
        echo "${COLOR_RED}$1${COLOR_OFF}"
    fi
}

# __symlink_installed_files_of_the_given_package <PACKAGE-NAME>
  __symlink_installed_files_of_the_given_package() {
      return 0
    # while read -r item
    # do
    #     X=$(printf '%s\n' "$item" | cut -d '|' -f1)
    #     Y=$(printf '%s\n' "$item" | cut -d '|' -f3)

    #     case $X in
    #         d)  ;;
    #         D)  ;;
    #         *)  case $Y in
    #                 share/info/dir) ;;
    #                 *)  if [ -L "$XCPKG_PACKAGE_SYMLINKED_ROOT/$Y" ] || [ -e "$XCPKG_PACKAGE_SYMLINKED_ROOT/$Y" ] ; then
    #                         die "$XCPKG_PACKAGE_SYMLINKED_ROOT/$Y already exists."
    #                     # else
    #                     #     echo "$XCPKG_PACKAGE_SYMLINKED_ROOT/$Y"
    #                     fi
    #             esac
    #     esac
    # done < "$PACKAGE_MANIFEST_FILEPATH"

    # ############################################################################

    if [ !      -d "$XCPKG_PACKAGE_SYMLINKED_ROOT/.registry" ] ; then
        install -d "$XCPKG_PACKAGE_SYMLINKED_ROOT/.registry"
    fi

    exec 7> "$XCPKG_PACKAGE_SYMLINKED_ROOT/.registry/$1"

    while read -r item
    do
        X=$(printf '%s\n' "$item" | cut -d '|' -f1)
        Y=$(printf '%s\n' "$item" | cut -d '|' -f3)

        case $X in
            d|D)
                if [ !      -d "$XCPKG_PACKAGE_SYMLINKED_ROOT/$Y" ] ; then
                    install -d "$XCPKG_PACKAGE_SYMLINKED_ROOT/$Y"
                fi
                ;;
            *)  case $Y in
                    share/info/dir) ;;
                    *)  run ln -sfr "\"$XCPKG_PACKAGE_INSTALLED_ROOT/$1/$Y\"" "\"$XCPKG_PACKAGE_SYMLINKED_ROOT/$Y\""
                        printf '%s\n' "$Y" >&7
                esac
        esac
    done < "$PACKAGE_MANIFEST_FILEPATH"

    exec 7>&-
}

# __generate_manifest_of_the_given_package <PACKAGE-NAME>
  __generate_manifest_of_the_given_package() {
    # fuck, some package's filename has space
    IFS_SAVED="$IFS"
    IFS='
'

    exec 7> "$PACKAGE_MANIFEST_FILEPATH"

    for dirname in $(find -mindepth 1 -maxdepth 1 -type d -not -name .xcpkg -printf '%P\n')
    do
        for item in $(find "$dirname" -printf '%y:%p\n')
        do
            X=$(printf '%s\n' "$item" | cut -c1)
            Y=${item#$X:}

            case $X in
                l)  if [ -d "$Y" ] ; then
                        printf 'D|0000000000000000000000000000000000000000000000000000000000000000|%s/\n' "$Y" >&7
                    else
                        printf 'l|%s|%s\n' "$(sha256sum "$Y" | cut -d ' ' -f1)"                           "$Y" >&7
                    fi
                    ;;
                d)  printf 'd|0000000000000000000000000000000000000000000000000000000000000000|%s/\n' "$Y" >&7 ;;
                *)  printf '%s|%s|%s\n' "$X" "$(sha256sum "$Y" | cut -d ' ' -f1)"                     "$Y" >&7 ;;
            esac
        done
    done

    exec 7>&-

    IFS="$IFS_SAVED"
}

# __generate_receipt_of_the_given_package <PACKAGE-NAME>
  __generate_receipt_of_the_given_package() {
    [ -z "$1" ] && {
        error "__generate_receipt_of_the_given_package <PACKAGE-NAME>, <PACKAGE-NAME> is unspecified."
        return 1
    }

    run cp "$PACKAGE_FORMULA_FILEPATH" "$PACKAGE_RECEIPT_FILEPATH"

    sed_in_place '/^#src-url: dir:/d' "$PACKAGE_RECEIPT_FILEPATH"

    sed_in_place "1i pkgname: $PACKAGE_NAME" "$PACKAGE_RECEIPT_FILEPATH"

    grep -q '^version: ' "$PACKAGE_RECEIPT_FILEPATH" || {
        sed_in_place "2i version: $PACKAGE_VERSION" "$PACKAGE_RECEIPT_FILEPATH"
    }

    grep -q '^web-url: ' "$PACKAGE_RECEIPT_FILEPATH" || {
        sed_in_place "/^git-url:/i web-url: $PACKAGE_GIT_URL" "$PACKAGE_RECEIPT_FILEPATH"
    }

    grep -q '^bsystem: ' "$PACKAGE_RECEIPT_FILEPATH" || {
        sed_in_place "/^install:/i bsystem: $PACKAGE_BSYSTEM" "$PACKAGE_RECEIPT_FILEPATH"
    }

    if [ -n "$PACKAGE_GIT_SHA" ] ; then
        grep -q '^git-sha: ' "$PACKAGE_RECEIPT_FILEPATH" || {
            sed_in_place "/^git-url:/a git-sha: $PACKAGE_GIT_SHA" "$PACKAGE_RECEIPT_FILEPATH"
        }

        grep -q '^git-sha: ' "$PACKAGE_RECEIPT_FILEPATH" || {
            sed_in_place "3i git-sha: $PACKAGE_GIT_SHA" "$PACKAGE_RECEIPT_FILEPATH"
        }
    fi

    if [ -n "$PACKAGE_DEP_UPP" ] ; then
        if grep -q '^dep-upp: ' "$PACKAGE_RECEIPT_FILEPATH" ; then
            sed_in_place "/^dep-upp: /c dep-upp: $PACKAGE_DEP_UPP" "$PACKAGE_RECEIPT_FILEPATH"
        else
            sed_in_place "/^bsystem: /i dep-upp: $PACKAGE_DEP_UPP" "$PACKAGE_RECEIPT_FILEPATH"
        fi
    fi

    grep -q '^parallel: ' "$PACKAGE_RECEIPT_FILEPATH" || {
        sed_in_place "\$a parallel: $PACKAGE_PARALLEL" "$PACKAGE_RECEIPT_FILEPATH"
    }

    cat >> "$PACKAGE_RECEIPT_FILEPATH" <<EOF

built-for: $TARGET_PLATFORM_NAME/$TARGET_PLATFORM_VERS/$TARGET_PLATFORM_ARCH

signature: $XCPKG_VERSION
timestamp: $TIMESTAMP_UNIX
EOF
}

# __load_receipt_of_the_given_package <PACKAGE-SPEC>
  __load_receipt_of_the_given_package() {
    [ -z "$1" ] && {
        error "__load_receipt_of_the_given_package <PACKAGE-SPEC>, <PACKAGE-SPEC> is unspecified."
        return 1
    }

    is_package_installed "$1" || {
        error "package [$1] is not installed."
        return 1
    }

    unset RECEIPT_PACKAGE_SUMMARY
    unset RECEIPT_PACKAGE_VERSION
    unset RECEIPT_PACKAGE_LICENSE

    unset RECEIPT_PACKAGE_WEB_URL

    unset RECEIPT_PACKAGE_GIT_URL
    unset RECEIPT_PACKAGE_GIT_SHA
    unset RECEIPT_PACKAGE_GIT_REF

    unset RECEIPT_PACKAGE_SVN_URL

    unset RECEIPT_PACKAGE_SRC_URL
    unset RECEIPT_PACKAGE_SRC_URI
    unset RECEIPT_PACKAGE_SRC_SHA

    unset RECEIPT_PACKAGE_FIX_URL
    unset RECEIPT_PACKAGE_FIX_SHA

    unset RECEIPT_PACKAGE_RES_URL
    unset RECEIPT_PACKAGE_RES_SHA

    unset RECEIPT_PACKAGE_DEP_PKG
    unset RECEIPT_PACKAGE_DEP_UPP
    unset RECEIPT_PACKAGE_DEP_PYM
    unset RECEIPT_PACKAGE_DEP_PLM

    unset RECEIPT_PACKAGE_BSYSTEM
    unset RECEIPT_PACKAGE_BSCRIPT
    unset RECEIPT_PACKAGE_PREPARE
    unset RECEIPT_PACKAGE_INSTALL
    unset RECEIPT_PACKAGE_SYMLINK

    unset RECEIPT_PACKAGE_PARALLEL

    #######################################################################################################

    PACKAGE_INSTALLED_DIR="$XCPKG_PACKAGE_INSTALLED_ROOT/$1"
    PACKAGE_RECEIPT_FILEPATH="$PACKAGE_INSTALLED_DIR/.xcpkg/receipt.yml"

    unset PACKAGE_RECEIPT_SIGNATURE
    unset PACKAGE_RECEIPT_TIMESTAMP

    PACKAGE_RECEIPT_SIGNATURE="$(yq .signature "$PACKAGE_RECEIPT_FILEPATH")"
    PACKAGE_RECEIPT_TIMESTAMP="$(yq .timestamp "$PACKAGE_RECEIPT_FILEPATH")"

    if [ -z "$PACKAGE_RECEIPT_SIGNATURE" ] ; then
        error "$PACKAGE_RECEIPT_FILEPATH is broken. value of PACKAGE_RECEIPT_SIGNATURE must be non-empty."
        return 1
    fi

    if [ -z "$PACKAGE_RECEIPT_TIMESTAMP" ] ; then
        error "$PACKAGE_RECEIPT_FILEPATH is broken. value of PACKAGE_RECEIPT_TIMESTAMP must be non-empty."
        return 1
    fi

    #######################################################################################################

    for key in summary web-url git-url git-sha git-ref shallow src-url src-uri src-sha fix-url fix-sha res-url res-sha dep-pkg dep-upp dep-pym dep-plm license version bsystem bscript binbstd cdefine ccflags xxflags ldflags parallel exetype symlink
    do
        unset __KEY_UPPERCASE_UNDERSCORE__
        unset __VALUE__

        __KEY_UPPERCASE_UNDERSCORE__="$(printf '%s\n' "$key" | tr '-' '_' | tr a-z A-Z)"
        __VALUE__="$(yq ".$key" "$PACKAGE_RECEIPT_FILEPATH")"

        if [ "$__VALUE__" = null ] ; then
                __VALUE__=
        fi

        eval "RECEIPT_PACKAGE_$__KEY_UPPERCASE_UNDERSCORE__='$__VALUE__'"
    done

    if [ -z "$RECEIPT_PACKAGE_VERSION" ] ; then
        error "$PACKAGE_RECEIPT_FILEPATH is broken. value of RECEIPT_PACKAGE_VERSION must be non-empty."
        return 1
    fi

    if [ -z "$RECEIPT_PACKAGE_SUMMARY" ] ; then
        error "$PACKAGE_RECEIPT_FILEPATH is broken. value of RECEIPT_PACKAGE_SUMMARY must be non-empty."
        return 1
    fi

    if [ -z "$RECEIPT_PACKAGE_WEB_URL" ] ; then
        error "$PACKAGE_RECEIPT_FILEPATH is broken. value of RECEIPT_PACKAGE_WEB_URL must be non-empty."
        return 1
    fi

    if [ "${#PACKAGE_RECEIPT_TIMESTAMP}" -ne 10 ] ; then
        error "$PACKAGE_RECEIPT_FILEPATH is broken. length of \$PACKAGE_RECEIPT_TIMESTAMP must be 10."
        return 1
    fi
}

# __config_variables_for_the_given_target <PACKAGE-NAME>
# __config_variables_for_the_given_target      curl
#
#
## References:
# https://clang.llvm.org/docs/ClangCommandLineReference.html
# https://clang.llvm.org/docs/CommandGuide/clang.html#cmdoption-mmacosx-version-min
# https://clang.llvm.org/docs/CommandGuide/clang.html#envvar-MACOSX_DEPLOYMENT_TARGET
# https://clang.llvm.org/docs/CrossCompilation.html
# https://commandlinefanatic.com/cgi-bin/showarticle.cgi?article=art024
#
__config_variables_for_the_given_target() {
    export       CC_FOR_BUILD="$TOOLCHAIN_BIND/clang"
    export      CXX_FOR_BUILD="$TOOLCHAIN_BIND/clang++"
    export      CPP_FOR_BUILD="$TOOLCHAIN_BIND/clang -E"

    ##################################################################################

    export   CFLAGS_FOR_BUILD="-isysroot $TOOLCHAIN_ROOT/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk -mmacosx-version-min=$NATIVE_OS_VERS -arch $NATIVE_OS_ARCH -Qunused-arguments"
    export CXXFLAGS_FOR_BUILD="-isysroot $TOOLCHAIN_ROOT/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk -mmacosx-version-min=$NATIVE_OS_VERS -arch $NATIVE_OS_ARCH -Qunused-arguments"
    export CPPFLAGS_FOR_BUILD="-isysroot $TOOLCHAIN_ROOT/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk -Qunused-arguments"
    export  LDFLAGS_FOR_BUILD="-isysroot $TOOLCHAIN_ROOT/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk -mmacosx-version-min=$NATIVE_OS_VERS -arch $NATIVE_OS_ARCH"

    ##################################################################################

    export       CC="$TOOLCHAIN_BIND/clang"
    export      CXX="$TOOLCHAIN_BIND/clang++"
    export      CPP="$TOOLCHAIN_BIND/clang -E"
    export       AS="$TOOLCHAIN_BIND/as"
    export       AR="$TOOLCHAIN_BIND/ar"
    export   RANLIB="$TOOLCHAIN_BIND/ranlib"
    export       LD="$TOOLCHAIN_BIND/ld"
    export       NM="$TOOLCHAIN_BIND/nm"
    export    STRIP="$TOOLCHAIN_BIND/strip"
    export     SIZE="$TOOLCHAIN_BIND/size"
    export  STRINGS="$TOOLCHAIN_BIND/strings"
    export  OBJDUMP="$TOOLCHAIN_BIND/objdump"

    ##################################################################################

    case $TARGET_PLATFORM_ARCH in
        armv7*) CPPFLAGS="-D__arm__"   ;;
        arm64*) CPPFLAGS="-D__arm64__" ;;
        i386)   CPPFLAGS="-D__i386__"  ;;
        x86_64) CPPFLAGS="-D__x86_64__";;
    esac

    for item in $PACKAGE_CDEFINE
    do
        CPPFLAGS="$CPPFLAGS -D$item"
    done

    CCFLAGS="-fPIC -fno-common $PACKAGE_CCFLAGS"
    XXFLAGS="-fPIC -fno-common $PACKAGE_XXFLAGS"
    LDFLAGS="$PACKAGE_LDFLAGS"

    CCFLAGS="$(printf '%s\n' "$CCFLAGS" | sed -e 's|--static||g' -e 's|-static||g')"
    XXFLAGS="$(printf '%s\n' "$XXFLAGS" | sed -e 's|--static||g' -e 's|-static||g')"
    LDFLAGS="$(printf '%s\n' "$LDFLAGS" | sed -e 's|--static||g' -e 's|-static||g')"

    ##################################################################################

    SYSROOT="$TOOLCHAIN_ROOT/Platforms/${TARGET_PLATFORM_NAME}.platform/Developer/SDKs/${TARGET_PLATFORM_NAME}.sdk"

    TARGET_PLATFORM_NAME_LOWER_CASE="$(printf "$TARGET_PLATFORM_NAME" | tr A-Z a-z)"

    CPPFLAGS="-isysroot $SYSROOT -Qunused-arguments $CPPFLAGS"
     CCFLAGS="-isysroot $SYSROOT -arch $TARGET_PLATFORM_ARCH -m${TARGET_PLATFORM_NAME_LOWER_CASE}-version-min=$TARGET_PLATFORM_VERS -Qunused-arguments $CCFLAGS"
     XXFLAGS="-isysroot $SYSROOT -arch $TARGET_PLATFORM_ARCH -m${TARGET_PLATFORM_NAME_LOWER_CASE}-version-min=$TARGET_PLATFORM_VERS -Qunused-arguments $XXFLAGS"
     LDFLAGS="-isysroot $SYSROOT -arch $TARGET_PLATFORM_ARCH -m${TARGET_PLATFORM_NAME_LOWER_CASE}-version-min=$TARGET_PLATFORM_VERS -Wl,-search_paths_first"

    [ "$LOG_LEVEL" -ge 3 ] && {
        CCFLAGS="$CCFLAGS -v"
        XXFLAGS="$XXFLAGS -v"
        LDFLAGS="$LDFLAGS -Wl,-v"
    }

    [ "$BUILD_TYPE" = release ] && {
       CPPFLAGS="$CPPFLAGS -DNDEBUG"
        CCFLAGS="$CCFLAGS -Os"
        XXFLAGS="$XXFLAGS -Os"
        LDFLAGS="$LDFLAGS -Wl,-S"
    }

    ##################################################################################

    # https://www.freedesktop.org/wiki/Software/pkg-config/CrossCompileProposal
    unset PKG_CONFIG_SYSROOT_DIR
    unset PKG_CONFIG_LIBDIR
    unset PKG_CONFIG_PATH

    # https://cmake.org/cmake/help/latest/variable/CMAKE_FIND_ROOT_PATH.html
    # https://cmake.org/cmake/help/latest/variable/CMAKE_IGNORE_PATH.html
    # https://cmake.org/cmake/help/latest/variable/CMAKE_PREFIX_PATH.html
    # https://cmake.org/cmake/help/latest/variable/CMAKE_INCLUDE_PATH.html
    # https://cmake.org/cmake/help/latest/variable/CMAKE_LIBRARY_PATH.html
    unset CMAKE_FIND_ROOT_PATH
    unset CMAKE_IGNORE_PATH
    unset CMAKE_PREFIX_PATH
    unset CMAKE_INCLUDE_PATH
    unset CMAKE_LIBRARY_PATH

    for DEPENDENT_PACKAGE_NAME in $RECURSIVE_DEPENDENT_PACKAGES
    do
        DEPENDENT_PACKAGE_INSTALL_DIR="$XCPKG_PACKAGE_INSTALLED_ROOT/$TARGET_PLATFORM_NAME/$TARGET_PLATFORM_VERS/$TARGET_PLATFORM_ARCH/$DEPENDENT_PACKAGE_NAME"
        DEPENDENT_PACKAGE_INCLUDE_DIR="$DEPENDENT_PACKAGE_INSTALL_DIR/include"
        DEPENDENT_PACKAGE_LIBRARY_DIR="$DEPENDENT_PACKAGE_INSTALL_DIR/lib"
        DEPENDENT_PACKAGE_PKGCONF_DIR="$DEPENDENT_PACKAGE_INSTALL_DIR/lib/pkgconfig"

        DEPENDENT_PACKAGE_NAME_UNDERSCORE=$(printf '%s\n' "$DEPENDENT_PACKAGE_NAME" | tr '+-.' '_')

        eval "${DEPENDENT_PACKAGE_NAME_UNDERSCORE}_INSTALL_DIR='$DEPENDENT_PACKAGE_INSTALL_DIR'"
        eval "${DEPENDENT_PACKAGE_NAME_UNDERSCORE}_INCLUDE_DIR='$DEPENDENT_PACKAGE_INCLUDE_DIR'"
        eval "${DEPENDENT_PACKAGE_NAME_UNDERSCORE}_LIBRARY_DIR='$DEPENDENT_PACKAGE_LIBRARY_DIR'"

        CPPFLAGS="-I$DEPENDENT_PACKAGE_INCLUDE_DIR $CPPFLAGS"
         LDFLAGS="-L$DEPENDENT_PACKAGE_LIBRARY_DIR $LDFLAGS"

        if [ -z "$PKG_CONFIG_PATH" ] ; then
            PKG_CONFIG_PATH="$DEPENDENT_PACKAGE_PKGCONF_DIR"
        else
            PKG_CONFIG_PATH="$PKG_CONFIG_PATH:$DEPENDENT_PACKAGE_PKGCONF_DIR"
        fi

        if [ -z "$CMAKE_FIND_ROOT_PATH" ] ; then
            CMAKE_FIND_ROOT_PATH="$DEPENDENT_PACKAGE_INSTALL_DIR"
        else
            CMAKE_FIND_ROOT_PATH="$CMAKE_FIND_ROOT_PATH;$DEPENDENT_PACKAGE_INSTALL_DIR"
        fi

        for item in bin sbin
        do
            if [ -d "$DEPENDENT_PACKAGE_INSTALL_DIR/$item" ] ; then
                if [ -z "$CMAKE_IGNORE_PATH" ] ; then
                    CMAKE_IGNORE_PATH="$DEPENDENT_PACKAGE_INSTALL_DIR/$item"
                else
                    CMAKE_IGNORE_PATH="$CMAKE_IGNORE_PATH;$DEPENDENT_PACKAGE_INSTALL_DIR/$item"
                fi
            fi
        done
    done

    unset DEPENDENT_PACKAGE_NAME
    unset DEPENDENT_PACKAGE_NAME_UNDERSCORE

    unset DEPENDENT_PACKAGE_INSTALL_DIR
    unset DEPENDENT_PACKAGE_INCLUDE_DIR
    unset DEPENDENT_PACKAGE_LIBRARY_DIR
    unset DEPENDENT_PACKAGE_PKGCONF_DIR

    export CPPFLAGS="-I$PACKAGE_WORKING_DIR/include $CPPFLAGS"
    export  LDFLAGS="-L$PACKAGE_WORKING_DIR/lib      $LDFLAGS"
    export   CFLAGS="$CCFLAGS"
    export CXXFLAGS="$XXFLAGS"

    export PATH="$PACKAGE_INSTALLING_BIN_DIR:$PATH"

    PKG_CONFIG_LIBDIR="$PKG_CONFIG_PATH"

    ##################################################################################

    unset PKG_CONFIG

    PKG_CONFIG=$(command -v pkg-config || command -v pkgconf || true)

    export PKG_CONFIG

    unset M4

    M4=$(command -v m4 || true)

    export M4

    ##################################################################################

    if [ "$PACKAGE_BUILD_SYSTEM_CMAKE" = yes ] ; then
        # https://cmake.org/cmake/help/latest/manual/cmake-env-variables.7.html#manual:cmake-env-variables(7)

        unset CMAKE_PREFIX_PATH
        unset CMAKE_APPLE_SILICON_PROCESSOR
        unset CMAKE_BUILD_PARALLEL_LEVEL
        unset CMAKE_BUILD_TYPE
        unset CMAKE_CONFIGURATION_TYPES
        unset CMAKE_CONFIG_TYPE
        unset CMAKE_EXPORT_COMPILE_COMMANDS
        unset CMAKE_GENERATOR
        unset CMAKE_GENERATOR_INSTANCE
        unset CMAKE_GENERATOR_PLATFORM
        unset CMAKE_GENERATOR_TOOLSET
        unset CMAKE_INSTALL_MODE
        unset CMAKE_C_COMPILER_LAUNCHER
        unset CMAKE_C_LINKER_LAUNCHER
        unset CMAKE_CXX_COMPILER_LAUNCHER
        unset CMAKE_CXX_LINKER_LAUNCHER
        unset CMAKE_MSVCIDE_RUN_PATH
        unset CMAKE_NO_VERBOSE
        unset CMAKE_OSX_ARCHITECTURES
        unset CMAKE_TOOLCHAIN_FILE
        unset DESTDIR
        unset CTEST_INTERACTIVE_DEBUG_MODE
        unset CTEST_OUTPUT_ON_FAILURE
        unset CTEST_PARALLEL_LEVEL
        unset CTEST_PROGRESS_OUTPUT
        unset CTEST_USE_LAUNCHERS_DEFAULT
        unset DASHBOARD_TEST_FROM_CTEST

        # https://cmake.org/cmake/help/latest/envvar/CMAKE_BUILD_PARALLEL_LEVEL.html
        export CMAKE_BUILD_PARALLEL_LEVEL="$BUILD_NJOBS"

        # https://cmake.org/cmake/help/latest/envvar/CMAKE_GENERATOR.html
        if [ "$PACKAGE_BUILD_SYSTEM_NINJA" = yes ] ; then
            export CMAKE_GENERATOR='Ninja'
        else
            export CMAKE_GENERATOR='Unix Makefiles'
        fi

        # https://cmake.org/cmake/help/latest/envvar/CMAKE_EXPORT_COMPILE_COMMANDS.html
        if [ "$EXPORT_COMPILE_COMMANDS_JSON" = yes ] ; then
            export CMAKE_EXPORT_COMPILE_COMMANDS=ON
        else
            export CMAKE_EXPORT_COMPILE_COMMANDS=OFF
        fi

        case $BUILD_TYPE in
            debug)   CMAKE_BUILD_TYPE=Debug   ;;
            release) CMAKE_BUILD_TYPE=Release ;;
        esac

        case $INSTALL_LIB in
            static)  BUILD_SHARED_LIBS=OFF ;;
            *)       BUILD_SHARED_LIBS=ON
        esac

        if [ "$LOG_LEVEL" -eq "$LOG_LEVEL_QUIET" ] ; then
            CMAKE_VERBOSE_MAKEFILE=OFF
            CMAKE_COLOR_MAKEFILE=OFF
        else
            CMAKE_VERBOSE_MAKEFILE=ON
            CMAKE_COLOR_MAKEFILE=ON
        fi

        # https://cmake.org/cmake/help/latest/variable/CMAKE_FIND_DEBUG_MODE.html
        if [ "$LOG_LEVEL" -ge "$LOG_LEVEL_DEBUG" ] ; then
            CMAKE_FIND_DEBUG_MODE=ON
        else
            CMAKE_FIND_DEBUG_MODE=OFF
        fi

        TARGET_CMAKE_TOOLCHAIN_FILE="$PACKAGE_WORKING_DIR/toolchain.cmake"
    fi

    ##################################################################################

    if [ "$PACKAGE_BUILD_SYSTEM_CARGO" = yes ] ; then
        case $TARGET_PLATFORM_NAME in
            MacOSX|*Simulator)
                case $TARGET_PLATFORM_ARCH in
                    arm64*) RUST_TARGET="aarch64-apple-darwin" ;;
                    *)      RUST_TARGET="$TARGET_PLATFORM_ARCH-apple-darwin"
                esac
                ;;
            *)  case $TARGET_PLATFORM_ARCH in
                    arm64*) RUST_TARGET="aarch64-apple-ios" ;;
                    *)      RUST_TARGET="$TARGET_PLATFORM_ARCH-apple-ios"
                esac
        esac

        # this environment variable is not defined by Rust, but it is widely used by third-party project.
        export RUST_TARGET="$RUST_TARGET"

        RUST_TARGET_UPPERCASE_UNDERSCORE=$(printf '%s\n' "$RUST_TARGET" | tr a-z A-Z | tr - _)

        # https://doc.rust-lang.org/cargo/reference/config.html#environment-variables
        # https://doc.rust-lang.org/cargo/reference/environment-variables.html
        export "CARGO_TARGET_${RUST_TARGET_UPPERCASE_UNDERSCORE}_AR"="$AR"
        export "CARGO_TARGET_${RUST_TARGET_UPPERCASE_UNDERSCORE}_LINKER"="$CC"

        export CARGO_BUILD_JOBS="$BUILD_NJOBS"

        # https://doc.rust-lang.org/rustc/codegen-options/index.html#link-arg
        export RUSTFLAGS="-Clinker=$CC -Clink-arg=-L$PACKAGE_WORKING_DIR/lib $RUSTFLAGS"

        # https://libraries.io/cargo/cc
        # https://crates.io/crates/cc
        # https://docs.rs/cc/latest/cc/
        # https://github.com/alexcrichton/cc-rs
        export HOST_CC="$CC_FOR_BUILD"
        export HOST_CFLAGS="$CFLAGS_FOR_BUILD"

        export HOST_CXX="$CXX_FOR_BUILD"
        export HOST_CXXFLAGS="$CXXFLAGS_FOR_BUILD"

        export HOST_AR="$AR_FOR_BUILD"

        export TARGET_CC="$CC"
        export TARGET_CFLAGS="$CFLAGS $CPPFLAGS $LDFLAGS"

        export TARGET_CXX="$CXX"
        export TARGET_CXXFLAGS="$CXXFLAGS $CPPFLAGS $LDFLAGS"

        export TARGET_AR="$AR"


        # https://libraries.io/cargo/pkg-config
        # https://crates.io/crates/pkg-config
        # https://docs.rs/pkg-config/latest/pkg_config/
        # https://github.com/rust-lang/pkg-config-rs
        export TARGET_PKG_CONFIG_ALLOW_CROSS=1


        # https://libraries.io/cargo/cmake
        # https://crates.io/crates/cmake
        # https://docs.rs/cmake/latest/cmake/
        # https://github.com/alexcrichton/cmake-rs
        # this variable is not motioned in their document. you must read the source code of cmake-rs crate.
        export TARGET_CMAKE_TOOLCHAIN_FILE="$TARGET_CMAKE_TOOLCHAIN_FILE"

        for item in $RECURSIVE_DEPENDENT_PACKAGES
        do
            case $item in
                openssl)
                    unset OPENSSL_DIR
                    # https://docs.rs/openssl/0.10.35/openssl/
                    export OPENSSL_DIR="$openssl_INSTALL_DIR"
                    ;;
            esac
        done
    fi

    ##################################################################################

    if [ "$PACKAGE_BUILD_SYSTEM_GO" = yes ] ; then
        # https://golang.org/doc/install/source#environment
        export CGO_ENABLED=1
        export CGO_CFLAGS="$CFLAGS"
        export CGO_CXXFLAGS="$CXXFLAGS"
        export CGO_CPPFLAGS="$CPPFLAGS"
        export CGO_LDFLAGS="$LDFLAGS"

        export GO111MODULE='auto'
        export GOPROXY='https://goproxy.cn'

        export GOOS="darwin"

        case $TARGET_PLATFORM_ARCH in
            armv7*)  export GOARCH=arm   ;;
            arm64*)  export GOARCH=arm64 ;;
            aarch64) export GOARCH=arm64 ;;
            i386)    export GOARCH=386   ;;
            i686)    export GOARCH=386   ;;
            x86_64)  export GOARCH=amd64 ;;
        esac
    fi
}

# __printf_variables_for_the_given_target <PACKAGE-NAME> <TARGET>
# __printf_variables_for_the_given_target      curl      iPhoneOS/arm64/8.0
__printf_variables_for_the_given_target() {
    printf '%s\n' "
              SHELL = $SHELL

                 M4 = $M4

XCPKG_VERSION       = $XCPKG_VERSION
XCPKG_HOME          = $XCPKG_HOME
XCPKG               = $XCPKG
XCPKG_URL_TRANSFORM = $XCPKG_URL_TRANSFORM

PACKAGE_WORKING_DIR = $PACKAGE_WORKING_DIR
PACKAGE_BSCRIPT_DIR = $PACKAGE_BSCRIPT_DIR
PACKAGE_BCACHED_DIR = $PACKAGE_BCACHED_DIR
PACKAGE_INSTALL_DIR = $PACKAGE_INSTALL_DIR

        BUILD_NJOBS = $BUILD_NJOBS
        BUILD_TYPE  = $BUILD_TYPE

     TIMESTAMP_UNIX = $TIMESTAMP_UNIX

     NATIVE_OS_KIND = $NATIVE_OS_KIND
     NATIVE_OS_TYPE = $NATIVE_OS_TYPE
     NATIVE_OS_VERS = $NATIVE_OS_VERS
     NATIVE_OS_ARCH = $NATIVE_OS_ARCH
     NATIVE_OS_NCPU = $NATIVE_OS_NCPU
     NATIVE_OS_EUID = $NATIVE_OS_EUID
     NATIVE_OS_EGID = $NATIVE_OS_EGID

TARGET_PLATFORM_SPEC = $TARGET_PLATFORM_SPEC
TARGET_PLATFORM_NAME = $TARGET_PLATFORM_NAME
TARGET_PLATFORM_VERS = $TARGET_PLATFORM_VERS
TARGET_PLATFORM_ARCH = $TARGET_PLATFORM_ARCH

     TOOLCHAIN_VERS = $TOOLCHAIN_VERS
     TOOLCHAIN_ROOT = $TOOLCHAIN_ROOT
     TOOLCHAIN_BIND = $TOOLCHAIN_BIND

            SYSROOT = $SYSROOT
    "

    for TOOL in CC CXX CPP AS AR RANLIB LD NM STRIP SIZE STRINGS OBJDUMP
    do
        eval export "$TOOL=\"\$$TOOL\""
        printf "%19s = %s\n" "$TOOL" "$(eval echo \$$TOOL)"
    done

    echo

    for TOOL in CC CXX CPP AS AR RANLIB LD NM STRIP SIZE STRINGS OBJDUMP
    do
        eval export "${TOOL}_FOR_BUILD=\"\$${TOOL}_FOR_BUILD\""
        printf "%19s = %s\n" "${TOOL}_FOR_BUILD" "$(eval echo \$${TOOL}_FOR_BUILD)"
    done

    echo

    for FLAG in CFLAGS CXXFLAGS CPPFLAGS LDFLAGS
    do
        eval export "$FLAG=\"\$$FLAG\""
        printf "\n%19s = " "$FLAG"
        FIRST=yes
        for item in $(eval echo \$$FLAG | tr ':' ' ')
        do
            if [ "$FIRST" = yes ] ; then
                FIRST=no
                echo "$item"
            else
                echo "                      $item"
            fi
        done
    done

    printf '%s\n'

    printf 'PKG_CONFIG          = %s\n' "$PKG_CONFIG"

    printf 'PKG_CONFIG_PATH     = '
    __printf_colon_separated_list "$PKG_CONFIG_PATH"

    printf '%s\n'

    printf 'PKG_CONFIG_LIBDIR   = '
    __printf_colon_separated_list "$PKG_CONFIG_LIBDIR"

    printf '%s\n'

    printf 'PKG_CONFIG_DEBUG_SPEW= %s\n\n' "$PKG_CONFIG_DEBUG_SPEW"

    printf '    LD_LIBRARY_PATH = '
    __printf_colon_separated_list "$LD_LIBRARY_PATH"

    printf "\n%19s = " ACLOCAL_PATH
    __printf_colon_separated_list "$ACLOCAL_PATH"

    printf "\n%19s = " PATH
    __printf_colon_separated_list "$PATH"

    if [ "$PACKAGE_BUILD_SYSTEM_CMAKE" = yes ] ; then
        printf '%s\n'
        env | sed -n '/^CMAKE_/p'
    fi

    if [ "$PACKAGE_BUILD_SYSTEM_CARGO" = yes ] ; then
        echo
        env | sed -n '/CARGO/p'
        echo
        env | sed -n '/RUST/p'
        echo
        cat <<EOF
    HOST_AR       = $HOST_AR
    HOST_CC       = $HOST_CC
    HOST_CXX      = $HOST_CXX
    HOST_CFLAGS   = $HOST_CFLAGS
    HOST_CXXFLAGS = $HOST_CXXFLAGS

  TARGET_AR       = $TARGET_AR
  TARGET_CC       = $TARGET_CC
  TARGET_CXX      = $TARGET_CXX
  TARGET_CFLAGS   = $TARGET_CFLAGS
  TARGET_CXXFLAGS = $TARGET_CXXFLAGS
EOF
    fi

    if [ "$PACKAGE_BUILD_SYSTEM_GO" = yes ] ; then
        echo
        for item_ in $(go env | tr ' ' '|')
        do
            unset item0
            unset item1
            unset item2

            item0=$(printf '%s\n' "$item_" | tr '|' ' ')
            item1=$(printf '%s\n' "$item0" | cut -d= -f1)
            item2=$(printf '%s\n' "$item0" | cut -d= -f2 | sed 's/^"//' | sed 's/"$//')

            printf '      %-12s = %s\n' "$item1" "$item2"
        done
    fi

    echo "
 PACKAGE_WORKING_DIR = $PACKAGE_WORKING_DIR
 PACKAGE_BCACHED_DIR = $PACKAGE_BCACHED_DIR
 PACKAGE_INSTALL_DIR = $PACKAGE_INSTALL_DIR
   "

    if [ "$LOG_LEVEL" -ge "$LOG_LEVEL_VERBOSE" ] ; then
        echo
        run export -p
        echo
    fi
}

__printf_colon_separated_list() {
    FIRST=yes

    for item in $(printf '%s\n' "$@" | tr ' ' '|' | tr ':' ' ')
    do
        if [ "$FIRST" = yes ] ; then
            FIRST=no
            printf '%s\n' "$item" | tr '|' ' '
        else
            printf '%s\n' "                      $item" | tr '|' ' '
        fi
    done
}

__create_cmake_toolchain_file_for_the_given_target() {
    cat > "$TARGET_CMAKE_TOOLCHAIN_FILE" <<EOF
set(CMAKE_VERBOSE_MAKEFILE $CMAKE_VERBOSE_MAKEFILE)
set(CMAKE_COLOR_MAKEFILE   $CMAKE_COLOR_MAKEFILE)

set(BUILD_SHARED_LIBS $BUILD_SHARED_LIBS)

set(CMAKE_BUILD_TYPE  $CMAKE_BUILD_TYPE)

set(CMAKE_SYSTEM_NAME      Darwin)
set(CMAKE_SYSTEM_VERSION   $TARGET_PLATFORM_VERS)
set(CMAKE_SYSTEM_PROCESSOR $TARGET_PLATFORM_ARCH)

set(CMAKE_ASM_COMPILER $CC)
set(CMAKE_ASM_FLAGS "-arch $TARGET_PLATFORM_ARCH")

set(CMAKE_C_COMPILER "$CC")
set(CMAKE_C_FLAGS "$CFLAGS $CPPFLAGS $LDFLAGS")

set(CMAKE_CXX_COMPILER "$CXX")
set(CMAKE_CXX_FLAGS "$CXXFLAGS $CPPFLAGS $LDFLAGS")

set(CMAKE_AR     "$AR")
set(CMAKE_NM     "$NM")
set(CMAKE_RANLIB "$RANLIB")
set(CMAKE_STRIP  "$STRIP")

set(CMAKE_OSX_SYSROOT "$SYSROOT")

# https://cmake.org/cmake/help/latest/variable/CMAKE_OSX_ARCHITECTURES.html
set(CMAKE_OSX_ARCHITECTURES "$TARGET_PLATFORM_ARCH" CACHE STRING "")

set(CMAKE_FIND_DEBUG_MODE $CMAKE_FIND_DEBUG_MODE)

set(CMAKE_FIND_ROOT_PATH "$CMAKE_FIND_ROOT_PATH")

set(CMAKE_LIBRARY_PATH "$SYSROOT/usr/lib")

set(CMAKE_IGNORE_PATH "$CMAKE_IGNORE_PATH")
EOF

    if [ "$LOG_LEVEL" -gt "$LOG_LEVEL_QUIET" ] ; then
        run cat "$TARGET_CMAKE_TOOLCHAIN_FILE"
    fi
}

gow() {
    # https://pkg.go.dev/cmd/go
    # https://pkg.go.dev/cmd/link

    unset GO_BUILD_ARGS
    unset GO_BUILD_ARGV_V
    unset GO_BUILD_ARGV_X
    unset GO_BUILD_ARGV_O
    unset GO_BUILD_ARGV_MOD
    unset GO_BUILD_ARGV_TAGS
    unset GO_BUILD_ARGV_LDFLAGS

    unset GO_BUILD_ARGS_EXTRA

    while [ -n "$1" ]
    do
        case $1 in
            -v) shift ; GO_BUILD_ARGV_V='-v' ;;
            -x) shift ; GO_BUILD_ARGV_X='-x' ;;
            -o) shift ; GO_BUILD_ARGV_O="$1" ; shift ;;
            -X) shift
                if [ -z "$GO_BUILD_ARGV_LDFLAGS" ] ; then
                    GO_BUILD_ARGV_LDFLAGS="-X $1"
                else
                    GO_BUILD_ARGV_LDFLAGS="$GO_BUILD_ARGV_LDFLAGS -X $1"
                fi
                shift
                ;;
            -ldflags)
                shift
                if [ -z "$GO_BUILD_ARGV_LDFLAGS" ] ; then
                    GO_BUILD_ARGV_LDFLAGS="$1"
                else
                    GO_BUILD_ARGV_LDFLAGS="$1 $GO_BUILD_ARGV_LDFLAGS"
                fi
                shift
                ;;
            *)  GO_BUILD_ARGS_EXTRA="$GO_BUILD_ARGS_EXTRA $1" ; shift
        esac
    done

    GO_BUILD_ARGS='-trimpath'

    if [ -z "$GO_BUILD_ARGV_V" ] ; then
        if [ "$LOG_LEVEL" -gt "$LOG_LEVEL_QUIET" ] ; then
            GO_BUILD_ARGS="$GO_BUILD_ARGS -v"
        fi
    else
        GO_BUILD_ARGS="$GO_BUILD_ARGS -v"
    fi

    if [ -z "$GO_BUILD_ARGV_X" ] ; then
        if [ "$LOG_LEVEL" -ge "$LOG_LEVEL_VERBOSE" ] ; then
            GO_BUILD_ARGS="$GO_BUILD_ARGS -x"
        fi
    else
        GO_BUILD_ARGS="$GO_BUILD_ARGS -x"
    fi

    if [ -z "$GO_BUILD_ARGV_LDFLAGS" ] ; then
        GO_BUILD_ARGS="$GO_BUILD_ARGS -ldflags '-s -w'"
    else
        GO_BUILD_ARGS="$GO_BUILD_ARGS -ldflags '-s -w $GO_BUILD_ARGV_LDFLAGS'"
    fi

    if [ -z "$GO_BUILD_ARGV_O" ] ; then
        GO_BUILD_ARGS="$GO_BUILD_ARGS -o $PACKAGE_BCACHED_DIR/"
    else
        GO_BUILD_ARGS="$GO_BUILD_ARGS -o $PACKAGE_BCACHED_DIR/$GO_BUILD_ARGV_O"
    fi

    GO_BUILD_ARGS="$GO_BUILD_ARGS $GO_BUILD_ARGS_EXTRA"

    run go build $GO_BUILD_ARGS || return 1

    for item in $(ls "$PACKAGE_BCACHED_DIR")
    do
        case $item in
            *.a)  run install_libs "$PACKAGE_BCACHED_DIR/$item" ;;
            *.so) run install_libs "$PACKAGE_BCACHED_DIR/$item" ;;
            *)    run install_bins "$PACKAGE_BCACHED_DIR/$item" ;;
        esac
    done
}

cargow() {
    case $1 in
        build)
            # https://doc.rust-lang.org/cargo/commands/cargo-clean.html
            # https://doc.rust-lang.org/cargo/commands/cargo-build.html

            unset CARGO_BUILD_ARGS
            unset CARGO_BUILD_ARG_VV
            unset CARGO_BUILD_ARG_TARGET
            unset CARGO_BUILD_ARG_RELEASE

            for arg in $@
            do
                case $arg in
                    --vv)      CARGO_BUILD_ARG_VV=set      ;;
                    --target)  CARGO_BUILD_ARG_TARGET=set  ;;
                    --release) CARGO_BUILD_ARG_RELEASE=set ;;
                esac
            done

            CARGO_BUILD_ARGS="$@"

            if [ -z "$CARGO_BUILD_ARG_VV" ] ; then
                CARGO_BUILD_ARGS="$CARGO_BUILD_ARGS -vv"
            fi

            if [ -z "$CARGO_BUILD_ARG_RELEASE" ] ; then
                CARGO_BUILD_ARGS="$CARGO_BUILD_ARGS --release"
            fi

            if [ -z "$CARGO_BUILD_ARG_TARGET" ] ; then
                CARGO_BUILD_ARGS="$CARGO_BUILD_ARGS --target $RUST_TARGET"
            fi

            run cargo clean && run cargo $CARGO_BUILD_ARGS
            ;;
        install)
            # https://doc.rust-lang.org/cargo/commands/cargo-clean.html
            # https://doc.rust-lang.org/cargo/commands/cargo-install.html

            unset CARGO_INSTALL_ARGS
            unset CARGO_INSTALL_ARG_TARGET
            unset CARGO_INSTALL_ARG_PATH
            unset CARGO_INSTALL_ARG_ROOT
            unset CARGO_INSTALL_ARG_VV

            for arg in $@
            do
                case $arg in
                    --target) CARGO_INSTALL_ARG_TARGET=set ;;
                    --path)   CARGO_INSTALL_ARG_PATH=set   ;;
                    --root)   CARGO_INSTALL_ARG_ROOT=set   ;;
                    --vv)     CARGO_INSTALL_ARG_VV=set     ;;
                esac
            done

            CARGO_INSTALL_ARGS="$@"

            if [ -z "$CARGO_INSTALL_ARG_VV" ] ; then
                CARGO_INSTALL_ARGS="$CARGO_INSTALL_ARGS -vv"
            fi

            if [ -z "$CARGO_INSTALL_ARG_TARGET" ] ; then
                CARGO_INSTALL_ARGS="$CARGO_INSTALL_ARGS --target $RUST_TARGET"
            fi

            if [ -z "$CARGO_INSTALL_ARG_PATH" ] ; then
                CARGO_INSTALL_ARGS="$CARGO_INSTALL_ARGS --path $PACKAGE_BSCRIPT_DIR"
            fi

            if [ -z "$CARGO_INSTALL_ARG_ROOT" ] ; then
                CARGO_INSTALL_ARGS="$CARGO_INSTALL_ARGS --root=$PACKAGE_INSTALL_DIR"
            fi

            run cargo clean && run cargo $CARGO_INSTALL_ARGS
            ;;
        cbuild|cinstall)
            unset CARGO_CINSTALL_ARGS
            unset CARGO_CINSTALL_ARG_Q
            unset CARGO_CINSTALL_ARG_V
            unset CARGO_CINSTALL_ARG_VV
            unset CARGO_CINSTALL_ARG_DEBUG
            unset CARGO_CINSTALL_ARG_RELEASE
            unset CARGO_CINSTALL_ARG_TARGET
            unset CARGO_CINSTALL_ARG_PREFIX

            for arg in $@
            do
                case $arg in
                    -q|--quiet)   CARGO_CINSTALL_ARG_Q=set       ;;
                    -v|--verbose) CARGO_CINSTALL_ARG_V=set       ;;
                    -vv)          CARGO_CINSTALL_ARG_VV=set      ;;
                    --debug)      CARGO_CINSTALL_ARG_DEBUG=set   ;;
                    --release)    CARGO_CINSTALL_ARG_RELEASE=set ;;
                    --target)     CARGO_CINSTALL_ARG_TARGET=set  ;;
                    --prefix)     CARGO_CINSTALL_ARG_PREFIX=set  ;;
                esac
            done

            CARGO_CINSTALL_ARGS="$@"

            if [ -z "$CARGO_CINSTALL_ARG_Q" ] && [ -z "$CARGO_CINSTALL_ARG_V" ] && [ -z "$CARGO_CINSTALL_ARG_VV" ] ; then
                CARGO_CINSTALL_ARGS="$CARGO_CINSTALL_ARGS -vv"
            fi

            if [ -z "$CARGO_CINSTALL_ARG_DEBUG" ] && [ -z "$CARGO_CINSTALL_ARG_RELEASE" ] ; then
                CARGO_CINSTALL_ARGS="$CARGO_CINSTALL_ARGS --release"
            fi

            if [ -z "$CARGO_CINSTALL_ARG_TARGET" ] ; then
                CARGO_CINSTALL_ARGS="$CARGO_CINSTALL_ARGS --target $RUST_TARGET"
            fi

            if [ -z "$CARGO_CINSTALL_ARG_PREFIX" ] ; then
                CARGO_CINSTALL_ARGS="$CARGO_CINSTALL_ARGS --prefix $PACKAGE_INSTALL_DIR"
            fi

            run cargo $CARGO_CINSTALL_ARGS
            ;;
        *) cargo $@
    esac
}

config_url() {
    echo "http://git.savannah.gnu.org/gitweb/?p=config.git;a=blob_plain;f=$1;hb=HEAD"
}

# run in a subshell
configure() {
    if [ -z "$CONFIG_XX_UPDATED" ] ; then
        CONFIG_XX_UPDATED=yes
        # https://www.gnu.org/software/gettext/manual/html_node/config_002eguess.html
        # https://git.savannah.gnu.org/cgit/config.git/tree/
        for item in config.sub config.guess
        do
            for file in $(find "$PACKAGE_BSCRIPT_DIR" -name "$item")
            do
                CONFIG_XX="$XCPKG_DOWNLOADS_DIR/config/$item"
                if [ ! -f "$CONFIG_XX" ] ; then
                    wfetch "$(config_url "$item")" --output-path="$CONFIG_XX" || return 1
                    run chmod a+x "$CONFIG_XX" || return 1
                    if [ "$item" = 'config.sub' ] ; then
                        sed_in_place 's/arm64-*/arm64-*|arm64e-*/g' "$CONFIG_XX" || return 1
                    fi
                fi
                run cp -f "$CONFIG_XX" "$file" || return 1
            done
        done
    fi

    if [ "$STEP_MESSAGE" = 'build for native' ] ; then
        if run "$PACKAGE_BSCRIPT_DIR"/configure \
            --prefix="$NATIVE_INSTALL_DIR" \
            $@ ; then
            echo
        else
            if [ -f "$PACKAGE_BCACHED_DIR/config.log" ] ; then
                run cat "$PACKAGE_BCACHED_DIR/config.log"
            elif [ -f "$PACKAGE_BSCRIPT_DIR/config.log" ] ; then
                run cat "$PACKAGE_BSCRIPT_DIR/config.log"
            fi
            return 1
        fi
    else
        unset TARGET_TRIPLE
        TARGET_TRIPLE=$(print_target_triple_by_arch "$TARGET_PLATFORM_ARCH")

        if run "$PACKAGE_BSCRIPT_DIR"/configure \
            --host="\"$TARGET_TRIPLE\"" \
            --prefix="\"$PACKAGE_INSTALL_DIR\"" \
            --disable-option-checking \
            --disable-rpath \
            --disable-debug \
            --disable-nls\
            --enable-largefile \
            --enable-static \
            --disable-shared \
            CC="\"$CC\"" \
            CFLAGS="\"$CFLAGS\"" \
            CXX="\"$CXX\"" \
            CXXFLAGS="\"$CXXFLAGS\"" \
            CPP="\"$CPP\"" \
            CPPFLAGS="\"$CPPFLAGS\"" \
            LDFLAGS="\"$LDFLAGS\"" \
            AR="\"$AR\"" \
            RANLIB="\"$RANLIB\"" \
            PKG_CONFIG="\"$PKG_CONFIG\"" \
            PKG_CONFIG_PATH="\"$PKG_CONFIG_PATH\"" \
            PKG_CONFIG_LIBDIR="\"\"" \
            CC_FOR_BUILD="\"$CC_FOR_BUILD\"" \
            $@ ; then
            echo
        else
            if [ -f "$PACKAGE_BCACHED_DIR/config.log" ] ; then
                run cat "$PACKAGE_BCACHED_DIR/config.log"
            elif [ -f "$PACKAGE_BSCRIPT_DIR/config.log" ] ; then
                run cat "$PACKAGE_BSCRIPT_DIR/config.log"
            fi
            return 1
        fi
    fi

    if [ "$LOG_LEVEL" -ge "$LOG_LEVEL_VERBOSE" ] ; then
        for Makefile in $(find "$PACKAGE_BSCRIPT_DIR" -name Makefile)
        do
            sed_in_place 's|\t@|\t|g'     "$Makefile" || return 1
            sed_in_place 's|@echo|echo|g' "$Makefile" || return 1
        done
        unset Makefile
    fi

    gmakew clean &&
    gmakew       &&
    gmakew install
}

# make wrapper
gmakew() {
    GMAKE=$(command -v gmake || command -v make) || die "command not found: make"

    run "$GMAKE" --version

    if [ "$LOG_LEVEL" -ge "$LOG_LEVEL_DEBUG" ] ; then
        run "$GMAKE -w -j$BUILD_NJOBS --debug V=1 $*"
    else
        run "$GMAKE -w -j$BUILD_NJOBS $*"
    fi
}

# https://cmake.org/cmake/help/latest/manual/cmake-toolchains.7.html#cross-compiling
# https://cmake.org/cmake/help/latest/variable/CMAKE_EXPORT_COMPILE_COMMANDS.html
# https://cmake.org/cmake/help/latest/variable/CMAKE_FIND_ROOT_PATH.html
# https://cmake.org/cmake/help/latest/variable/CMAKE_PREFIX_PATH.html
# https://cmake.org/cmake/help/latest/variable/CMAKE_INSTALL_PREFIX.html
# https://cmake.org/cmake/help/latest/variable/CMAKE_BUILD_TYPE.html
# https://cmake.org/cmake/help/latest/variable/BUILD_SHARED_LIBS.html
# https://cmake.org/cmake/help/latest/command/enable_testing.html?highlight=build_testing
# run in a subshell
cmakew() {
    CMAKE=$(command -v cmake) || die "command not found: cmake"

    if [ "$STEP_MESSAGE" = 'build for native' ] ; then
        # https://cmake.org/cmake/help/latest/variable/CMAKE_FIND_DEBUG_MODE.html
        if [ "$LOG_LEVEL" -ge "$LOG_LEVEL_DEBUG" ] ; then
            CMAKE_CONFIG_OPTIONS="$@ -DCMAKE_FIND_DEBUG_MODE=TRUE"
        else
            CMAKE_CONFIG_OPTIONS="$@"
        fi

        run $CMAKE \
            -Wno-dev \
            -S $PACKAGE_BSCRIPT_DIR \
            -B $NATIVE_BCACHED_DIR \
            -DCMAKE_INSTALL_PREFIX=$NATIVE_INSTALL_DIR \
            -DBUILD_SHARED_LIBS=OFF \
            -DCMAKE_EXPORT_COMPILE_COMMANDS=ON \
            -DBUILD_TESTING=OFF \
            $CMAKE_CONFIG_OPTIONS &&
        run $CMAKE --build   "$NATIVE_BCACHED_DIR" -- -j$BUILD_NJOBS &&
        run $CMAKE --install "$NATIVE_BCACHED_DIR"
    else
        run $CMAKE \
            -Wno-dev \
            -S $PACKAGE_BSCRIPT_DIR \
            -B $PACKAGE_BCACHED_DIR \
            -DCMAKE_INSTALL_PREFIX=$PACKAGE_INSTALL_DIR \
            -DCMAKE_TOOLCHAIN_FILE=$TARGET_CMAKE_TOOLCHAIN_FILE \
            -DCMAKE_VERBOSE_MAKEFILE=$CMAKE_VERBOSE_MAKEFILE \
            -DCMAKE_COLOR_MAKEFILE=$CMAKE_COLOR_MAKEFILE $@ &&
        run $CMAKE --build   "$PACKAGE_BCACHED_DIR" -- -j$BUILD_NJOBS &&
        run $CMAKE --install "$PACKAGE_BCACHED_DIR"
    fi
}

# run in a subshell
xmakew() {
    XMAKE=$(command -v xmake) || die "command not found: xmake"

    run "$XMAKE" --version

    XMAKE_CONFIG_OPTIONS="$@"

    XMAKE_CONFIG_OPTION_CLEAN=
    XMAKE_CONFIG_OPTION_MODE=
    XMAKE_CONFIG_OPTION_vD=

    for arg in $@
    do
        case $arg in
            -c|--clean)  XMAKE_CONFIG_OPTION_CLEAN=set ;;
            -m|--mode=*) XMAKE_CONFIG_OPTION_MODE=set  ;;
            -vD)         XMAKE_CONFIG_OPTION_vD=set ;;
        esac
    done

    if [ "$LOG_LEVEL" -ge "$LOG_LEVEL_DEBUG" ] && [ -z "$XMAKE_CONFIG_OPTION_vD" ]; then
        XMAKE_CONFIG_OPTIONS="$XMAKE_CONFIG_OPTION_vD -vD"
    fi

    if [ -z "$XMAKE_CONFIG_OPTION_CLEAN" ] ; then
        XMAKE_CONFIG_OPTIONS="$XMAKE_CONFIG_OPTIONS --clean"
    fi

    if [ -z "$XMAKE_CONFIG_OPTION_MODE" ] ; then
        XMAKE_CONFIG_OPTIONS="$XMAKE_CONFIG_OPTIONS --mode=$BUILD_TYPE"
    fi

    if [ "$STEP_MESSAGE" = 'build for native' ] ; then
        run $XMAKE config $XMAKE_CONFIG_OPTIONS --project=$PACKAGE_BSCRIPT_DIR --buildir=$NATIVE_BCACHED_DIR &&
        run $XMAKE --jobs=$BUILD_NJOBS &&
        run $XMAKE install -o "$NATIVE_INSTALL_DIR"
    else
        unset XMAKE_PLATFORM
        XMAKE_PLATFORM="$(printf '%s\n' "$TARGET_PLATFORM_NAME_LOWER_CASE" | sed 's|simulator|os|')"
        XMAKE_CONFIG_OPTIONS="$XMAKE_CONFIG_OPTIONS --plat=$XMAKE_PLATFORM"

        case $TARGET_PLATFORM_NAME in
            *Simulator) XMAKE_CONFIG_OPTIONS="$XMAKE_CONFIG_OPTIONS --appledev=simulator"
        esac

        XMAKE_CONFIG_OPTIONS="$XMAKE_CONFIG_OPTIONS --arch=$TARGET_PLATFORM_ARCH --buildir=$PACKAGE_BCACHED_DIR"

        run $XMAKE config $XMAKE_CONFIG_OPTIONS &&
        run $XMAKE --jobs=$BUILD_NJOBS &&
        run $XMAKE install -o "$PACKAGE_INSTALL_DIR"
    fi
}

# https://mesonbuild.com/Cross-compilation.html
# run in a subshell
mesonw() {
    case $TARGET_PLATFORM_ARCH in
        armv7*)
            HOST_MACHINE_CPU_FAMILY='arm'
            HOST_MACHINE_CPU_NAME="$TARGET_PLATFORM_ARCH"
            ;;
        arm64*|aarch64)
            HOST_MACHINE_CPU_FAMILY='aarch64'
            HOST_MACHINE_CPU_NAME='armv8a'
            ;;
        i386|i686)
            HOST_MACHINE_CPU_FAMILY='x86'
            HOST_MACHINE_CPU_NAME="$TARGET_PLATFORM_ARCH"
            ;;
        x86_64)
            HOST_MACHINE_CPU_FAMILY='x86_64'
            HOST_MACHINE_CPU_NAME="$TARGET_PLATFORM_ARCH"
            ;;
    esac

    MESON_CROSS_FILE="$PACKAGE_BCACHED_DIR/cross-file"

    cat > "$MESON_CROSS_FILE" <<EOF
[host_machine]
system = 'darwin'
endian = 'little'
cpu_family = '$HOST_MACHINE_CPU_FAMILY'
cpu = '$HOST_MACHINE_CPU_NAME'

[binaries]
c = '$CC'
cpp = '$CXX'
ar = '$AR'
strip = '$STRIP'
cmake = '$CMAKE'
pkgconfig = '$PKG_CONFIG'

EOF

    # https://mesonbuild.com/Machine-files.html#meson-builtin-options
    if command_exists_in_filesystem_and_version_matched meson lt 0.56.0 ; then
        cat >> "$MESON_CROSS_FILE" <<EOF
[properties]
c_args = $(to_meson_array $CFLAGS $CPPFLAGS)
c_link_args = $(to_meson_array $LDFLAGS)
cpp_args = $(to_meson_array $CXXFLAGS $CPPFLAGS)
cpp_link_args = $(to_meson_array $LDFLAGS)
EOF
    else
        cat >> "$MESON_CROSS_FILE" <<EOF
[built-in options]
c_args = $(to_meson_array $CFLAGS $CPPFLAGS)
c_link_args = $(to_meson_array $LDFLAGS)
cpp_args = $(to_meson_array $CXXFLAGS $CPPFLAGS)
cpp_link_args = $(to_meson_array $LDFLAGS)
EOF
        if [ "$PACKAGE_BUILD_SYSTEM_CMAKE" = yes ] ; then
            cat >> "$MESON_CROSS_FILE" <<EOF

[properties]
cmake_toolchain_file='$TARGET_CMAKE_TOOLCHAIN_FILE'
EOF
        fi
    fi

    unset MESON_ARGUMENT_DEFAULT_LIBRARY

    case $INSTALL_LIB in
        static|shared|both) MESON_ARGUMENT_DEFAULT_LIBRARY="-Ddefault_library=$INSTALL_LIB"
    esac

    run "$MESON" setup \
        --prefix="$PACKAGE_INSTALL_DIR" \
        --buildtype=$BUILD_TYPE \
        --backend=ninja \
        --pkg-config-path="$PKG_CONFIG_PATH" \
        --build.pkg-config-path="$PKG_CONFIG_PATH_FOR_BUILD" \
        --cross-file="$MESON_CROSS_FILE" \
        $MESON_ARGUMENT_DEFAULT_LIBRARY \
        $@ "$PACKAGE_BCACHED_DIR" "$PACKAGE_BSCRIPT_DIR" &&
    {
        if command -v build_configed > /dev/null ; then
            build_configed
        fi
    } &&
    run ninja -C "$PACKAGE_BCACHED_DIR" &&
    run ninja -C "$PACKAGE_BCACHED_DIR" install
}

to_meson_array() {
    RESULT="[''"
    for item in $@
    do
        RESULT="$RESULT, '$item'"
    done
    RESULT="$RESULT]"
    echo "$RESULT"
}

inject_stub_system() {
    cat > "$PACKAGE_BSCRIPT_DIR/stub-system.c" <<EOF
#ifndef SYSTEM_STUB_C
#define SYSTEM_STUB_C

#include <stdlib.h>
#include <unistd.h>
#include <spawn.h>
#include <sys/wait.h>

extern char **environ;

#ifdef __cplusplus
    extern "C" {
#endif

__attribute__((unused))
static int stub_system(char* cmd) {
    char argv0[] = "sh";
    char argv1[] = "-c";
    char* const argv[4] = {argv0, argv1, cmd, NULL};
    pid_t pid;
    int status;
    status = posix_spawn(&pid, "/bin/sh", NULL, NULL, argv, environ);
    if (0 == status) {
        return waitpid(pid, &status, 0);
    }
    return status;
}

#define system(x) stub_system(x)

#ifdef __cplusplus
    }
#endif

#endif
EOF
    for item in $@
    do
        echo "inject $PACKAGE_BSCRIPT_DIR/stub-system.c -> $item"
        cat "$PACKAGE_BSCRIPT_DIR/stub-system.c" "$item" > "$item.bak" || return 1
        mv "$item.bak" "$item" || return 1
    done
}

inspect_xcode_information() {
    if [ -z "$DEVELOPER_DIR" ] ; then
        export DEVELOPER_DIR="$(xcode-select -p)"
    fi

    TOOLCHAIN_ROOT="$DEVELOPER_DIR"

    [ -z "$TOOLCHAIN_ROOT" ] && die "please run command 'xcode-select --switch DIR', then try again."
    [ -d "$TOOLCHAIN_ROOT" ] || die "TOOLCHAIN_ROOT=$TOOLCHAIN_ROOT directory is not exist."

    TOOLCHAIN_VERS=$(system_profiler SPDeveloperToolsDataType | grep Version | head -n 1 | cut -d: -f2 | sed 's/^ //g')
    TOOLCHAIN_BIND="$TOOLCHAIN_ROOT/Toolchains/XcodeDefault.xctoolchain/usr/bin"

    export       CC="$TOOLCHAIN_BIND/clang"
    export      CXX="$TOOLCHAIN_BIND/clang++"
    export      CPP="$TOOLCHAIN_BIND/cpp"
    export       AS="$TOOLCHAIN_BIND/as"
    export       AR="$TOOLCHAIN_BIND/ar"
    export   RANLIB="$TOOLCHAIN_BIND/ranlib"
    export       LD="$TOOLCHAIN_BIND/ld"
    export       NM="$TOOLCHAIN_BIND/nm"
    export    STRIP="$TOOLCHAIN_BIND/strip"
    export     SIZE="$TOOLCHAIN_BIND/size"
    export  STRINGS="$TOOLCHAIN_BIND/strings"
    export  OBJDUMP="$TOOLCHAIN_BIND/objdump"


    #export PATH="$TOOLCHAIN_BIND:$PATH"
}

__list_supported_target_platforms() {
    [ -z "$TOOLCHAIN_ROOT" ] && inspect_xcode_information
    ls "$TOOLCHAIN_ROOT/Platforms" | sed 's/.platform//g'
    #print_list AppleTVOS AppleTVSimulator MacOSX iPhoneOS iPhoneSimulator WatchOS WatchSimulator
}

# __list_supported_target_archs [32bit|64bit|all] [iPhoneOS|WatchOS|AppleTVOS|MacOSX|*Simulator|table|list]
__list_supported_target_archs() {
    unset LIST_SUPPORTED_ARCHS_ARG_BIT
    unset LIST_SUPPORTED_ARCHS_ARG_PLATFORM

    while [ -n "$1" ]
    do
        case $1 in
            32bit|64bit|all)
                LIST_SUPPORTED_ARCHS_ARG_BIT=$1
                ;;
            iPhoneOS|WatchOS|AppleTVOS|MacOSX|*Simulator|table|list)
                LIST_SUPPORTED_ARCHS_ARG_PLATFORM=$1
                ;;
            *) die "unrecognized argument : $1."
        esac
        shift
    done

    if [ -z "$LIST_SUPPORTED_ARCHS_ARG_BIT" ] ; then
        LIST_SUPPORTED_ARCHS_ARG_BIT=all
    fi

    if [ -z "$LIST_SUPPORTED_ARCHS_ARG_PLATFORM" ] ; then
        LIST_SUPPORTED_ARCHS_ARG_PLATFORM=list
    fi

    case $LIST_SUPPORTED_ARCHS_ARG_BIT in
        all)
            case $LIST_SUPPORTED_ARCHS_ARG_PLATFORM in
                iPhoneOS)   echo "arm64 arm64e armv7 armv7s" ;;
                WatchOS)    echo "arm64_32 armv7k" ;;
                AppleTVOS)  echo "arm64"       ;;
                MacOSX)     echo "arm64 x86_64 i386" ;;
                *Simulator) echo "arm64 x86_64 i386" ;;
                list)       echo "arm64 arm64e arm64_32 armv7 armv7s armv7k x86_64" ;;
                table) __print_platform_arch_table_all ;;
                *)  die "unsupported platform : $LIST_SUPPORTED_ARCHS_ARG_PLATFORM."
            esac
            ;;
        64bit)
            case $LIST_SUPPORTED_ARCHS_ARG_PLATFORM in
                iPhoneOS)   echo "arm64 arm64e" ;;
                WatchOS)    echo "arm64_32" ;;
                AppleTVOS)  echo "arm64"  ;;
                MacOSX)     echo "arm64 x86_64" ;;
                *Simulator) echo "arm64 x86_64" ;;
                list)       echo "arm64 arm64e arm64_32 x86_64" ;;
                table) __print_platform_arch_table_64bit ;;
                *)  die "unsupported platform : $LIST_SUPPORTED_ARCHS_ARG_PLATFORM."
            esac
            ;;
        32bit)
            case $LIST_SUPPORTED_ARCHS_ARG_PLATFORM in
                iPhoneOS)   echo "armv7 armv7s" ;;
                WatchOS)    echo "armv7k" ;;
                AppleTVOS)  die "AppleTVOS is not support 32bit."  ;;
                MacOSX)     echo "i386" ;;
                *Simulator) echo "i386" ;;
                list)       echo "armv7 armv7s armv7k i386" ;;
                table) __print_platform_arch_table_32bit ;;
                *)  die "unsupported platform : $LIST_SUPPORTED_ARCHS_ARG_PLATFORM."
            esac
            ;;
    esac
}

__print_platform_arch_table_64bit() {
    cat <<EOF
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ platform   â”‚ arch                      â”‚
â”‚            â”‚                           â”‚
â”‚ AppleTVOS  â”‚ arm64                     â”‚
â”‚ WatchOS    â”‚ arm64_32                  â”‚
â”‚ iPhoneOS   â”‚ arm64 arm64e              â”‚
â”‚ MacOSX     â”‚ arm64 x86_64              â”‚
â”‚ *Simulator â”‚ arm64 x86_64              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
EOF
}

__print_platform_arch_table_32bit() {
    cat <<EOF
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ platform   â”‚ arch                      â”‚
â”‚            â”‚                           â”‚
â”‚ AppleTVOS  â”‚                           â”‚
â”‚ WatchOS    â”‚ armv7k                    â”‚
â”‚ iPhoneOS   â”‚ armv7 armv7s              â”‚
â”‚ MacOSX     â”‚ i386                      â”‚
â”‚ *Simulator â”‚ i386                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
EOF
}

__print_platform_arch_table_all() {
    cat <<EOF
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ platform   â”‚ arch                      â”‚
â”‚            â”‚                           â”‚
â”‚ AppleTVOS  â”‚ arm64                     â”‚
â”‚ WatchOS    â”‚ arm64_32 armv7k           â”‚
â”‚ iPhoneOS   â”‚ arm64 arm64e armv7 armv7s â”‚
â”‚ MacOSX     â”‚ arm64 x86_64              â”‚
â”‚ *Simulator â”‚ arm64 x86_64              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
EOF
}

# __list_supported_target_abis 32bit|64bit|all
__list_supported_target_abis() {
    for PLATFORM in $(__list_supported_target_platforms)
    do
        for ARCH in $(__list_supported_target_archs $PLATFORM ${1-all} 2>/dev/null)
        do
            echo "$PLATFORM/$ARCH"
        done
    done
}

# __list_supported_target_triples 32bit|64bit|all
__list_supported_target_triples() {
    for ARCH in $(__list_supported_target_archs list ${1-all} 2>/dev/null)
    do
        print_target_triple_by_arch "$ARCH"
    done
}

print_target_triple_by_arch() {
    if [ 'arm64' = "$1" ] ; then
        if [ "$PACKAGE_IOS_IOS" = yes ] ; then
            echo 'aarch64-apple-ios'
        else
            echo 'aarch64-apple-darwin'
        fi
    else
        if [ "$PACKAGE_IOS_IOS" = yes ] ; then
            echo "$1-apple-ios"
        else
            echo "$1-apple-darwin"
        fi
    fi
}

__list_supported_target_platform_versions() {
    if [ -z "$1" ] ; then
        for PLATFORM in $(__list_supported_target_platforms)
        do
            printf "%-16s : $(__list_supported_target_platform_versions "$PLATFORM")\n" "$PLATFORM"
        done
    else
        case $1 in
            iPhoneOS|iPhoneSimulator)   echo "8.0 8.1 8.2 8.3 8.4 9.0 9.1 9.2 9.3 10.0 10.1 10.2 10.3 11.0 11.1 11.2 11.3 11.4 12.0 12.1 12.2 12.3 12.4 13.0 13.1 13.2 13.3 13.4 13.5";;
            WatchOS|WatchSimulator)     echo "2.0 2.1 2.2 3.0 3.1 3.2 4.0 4.1 4.2 4.3 5.0 5.1 5.2 5.3 6.0 6.1 6.2";;
            AppleTVOS|AppleTVSimulator) echo "9.0 9.1 9.2 10.0 10.1 10.2 11.0 11.1 11.2 11.3 11.4 12.0 12.1 12.3 12.4 13.0 13.1 13.2 13.3";;
            MacOSX)                     echo "10.6 10.7 10.8 10.9 10.10 10.11 10.12 10.13 10.14 10.15";;
            *)                          die "unsupported platform : $1."
        esac
    fi
}

get_supported_min_version() {
    if [ -z "$1" ] ; then
        for PLATFORM in $(__list_supported_target_platforms)
        do
            printf "%-16s : %s\n" "$PLATFORM" $(get_supported_min_version "$PLATFORM")
        done
    else
        __list_supported_target_platform_versions "$1" | awk '{print $1}'
    fi
}

__create_framework_for_the_given_packages() {
    die_if_package_list_is_not_specified "$1"

    for PACKAGE in $@
    do
        __create_framework_for_the_given_package "$PACKAGE"
    done
}

__create_framework_for_the_given_package() {
    die_if_package_is_not_installed "$1"

    unset -f create_framework

    __load_formula_of_the_given_package "$1"
    
    if command -v create_framework > /dev/null ; then
        create_framework
    else
        die "create_framework mapping not found in formula $MY_FORMULA_DIR/$1.yml"
    fi
}

inspect_install_arguments() {
    inspect_xcode_information

    # https://stackoverflow.com/questions/18476490/what-is-purpose-of-target-arch-variable-in-makefiles
    unset TARGET_ARCH

    unset USER_SPECIFIED_PACKAGE_SPEC_LIST

    unset DRYRUN

    CCACHE_ENABLED=no

    LOG_LEVEL_QUIET=0
    LOG_LEVEL_NORMAL=1
    LOG_LEVEL_VERBOSE=2
    LOG_LEVEL_DEBUG=3

    LOG_LEVEL=$LOG_LEVEL_NORMAL

    BUILD_NJOBS=$NATIVE_OS_NCPU

    BUILD_TYPE=release

    LINK_TYPE=static-prefered

    INSTALL_EXE=yes
    INSTALL_MAN=yes
    INSTALL_DOC=yes
    INSTALL_LIB=yes

    KEEP_WORKING_DIR=no

    while [ -n "$1" ]
    do
        case $1 in
            --debug|-d)
                LOG_LEVEL=$LOG_LEVEL_DEBUG
                ;;
            --verbose|-v)
                LOG_LEVEL=$LOG_LEVEL_VERBOSE
                ;;
            --quiet|-q)
                LOG_LEVEL=$LOG_LEVEL_QUIET
                ;;
            --disable-ccache)
                CCACHE_ENABLED=no
                ;;
            --dry-run)
                DRYRUN=yes
                ;;
            --keep-working-dir)
                KEEP_WORKING_DIR=yes
                ;;
            --install-doc)
                INSTALL_DOC=yes
                ;;
            --install-man)
                INSTALL_MAN=yes
                ;;
            --install-exe)
                INSTALL_EXE=yes
                ;;
            --install-lib=*)
                INSTALL_LIB=$(getvalue "$1")
                case $INSTALL_LIB in
                    static|shared|both|yes|no) ;;
                    '') die "--install-lib=<VALUE>, VALUE must be non-empty." ;;
                    *)  die "--install-lib=<VALUE>, VALUE must be one of static|shared|both|yes|no"
                esac
                ;;
            --build-type=*)
                BUILD_TYPE=$(getvalue "$1")
                case $BUILD_TYPE in
                    debug|release) ;;
                    '') die "--build-type=<VALUE>, VALUE must be non-empty." ;;
                    *)  die "--build-type=<VALUE>, VALUE must be one of debug|release"
                esac
                ;;
            --link-type=*)
                LINK_TYPE=$(getvalue "$1")
                case $LINK_TYPE in
                    static-only|shared-only|static-prefered|shared-prefered) ;;
                    '') die "--link-type=<VALUE>, VALUE must be non-empty." ;;
                    *)  die "--link-type=<VALUE>, VALUE must be one of static-only|shared-only|static-prefered|shared-prefered"
                esac
                ;;
            --jobs=*)
                BUILD_NJOBS=$(getvalue "$1")
                is_integer "$BUILD_NJOBS" || die "--jobs=INTEGER argument's value must be an integer."
                ;;
            -*) die "unrecognized option: $1"
                ;;
            *)  if printf '%s\n' "$1" | grep -q -E '^[A-Za-z0-9+-._]{1,50}$' ; then
                    PACKAGE_NAME="$1"
                    PACKAGE_SPEC="MacOSX/$NATIVE_OS_VERS/$NATIVE_OS_ARCH/$PACKAGE_NAME"

                    warn "$1 will be treated as a package name, and it will be expanded to $PACKECK_SPEC"

                    if [ -z "$USER_SPECIFIED_PACKAGE_SPEC_LIST" ] ; then
                        USER_SPECIFIED_PACKAGE_SPEC_LIST="$PACKAGE_SPEC"
                    else
                        USER_SPECIFIED_PACKAGE_SPEC_LIST="$USER_SPECIFIED_PACKAGE_SPEC_LIST $PACKAGE_SPEC"
                    fi
                else
                    case $1 in
                        */*/*/*)
                            unset PACKAGE_NAME

                            unset TARGET_PLATFORM_NAME
                            unset TARGET_PLATFORM_VERS
                            unset TARGET_PLATFORM_ARCH

                            TARGET_PLATFORM_NAME=$(printf '%s\n' "$1" | cut -d/ -f1)
                            TARGET_PLATFORM_VERS=$(printf '%s\n' "$1" | cut -d/ -f2)
                            TARGET_PLATFORM_ARCH=$(printf '%s\n' "$1" | cut -d/ -f3)
                                    PACKAGE_NAME=$(printf '%s\n' "$1" | cut -d/ -f4)

                            if [ -z "$PACKAGE_NAME" ] ; then
                                die "invalid package spec: $1\npackage name is unspecified."
                            fi

                            case $TARGET_PLATFORM_NAME in
                                MacOSX|AppleTVOS|iPhoneOS|WatchOS|AppleTVSimulator|iPhoneSimulator|WatchSimulator)
                                    ;;
                                '') TARGET_PLATFORM_NAME=MacOSX ;;
                                *)  die "invalid package spec: $1\nunrecognized platform name: $TARGET_PLATFORM_NAME"
                            esac

                            if [ -z "$TARGET_PLATFORM_VERS" ] ; then
                                case $TARGET_PLATFORM_NAME in
                                    iPhoneOS|iPhoneSimulator)
                                        TARGET_PLATFORM_VERS=9.0
                                        ;;
                                    WatchOS|WatchSimulator)
                                        TARGET_PLATFORM_VERS=5.0
                                        ;;
                                    AppleTVOS|AppleTVSimulator)
                                        TARGET_PLATFORM_VERS=9.0
                                        ;;
                                    MacOSX)
                                        TARGET_PLATFORM_VERS=$NATIVE_OS_VERS
                                        ;;
                                esac
                            fi

                            if [ -z "$TARGET_PLATFORM_ARCH" ] ; then
                                case $TARGET_PLATFORM_NAME in
                                    WatchOS)
                                        TARGET_PLATFORM_ARCH=arm64_32
                                        ;;
                                    WatchSimulator)
                                        TARGET_PLATFORM_ARCH=arm64
                                        ;;
                                    iPhoneOS|iPhoneSimulator)
                                        TARGET_PLATFORM_ARCH=arm64
                                        ;;
                                    AppleTVOS|AppleTVSimulator)
                                        TARGET_PLATFORM_ARCH=arm64
                                        ;;
                                    MacOSX)
                                        TARGET_PLATFORM_ARCH=$NATIVE_OS_ARCH
                                        ;;
                                esac
                            fi

                            PACKAGE_SPEC="$TARGET_PLATFORM_NAME/$TARGET_PLATFORM_VERS/$TARGET_PLATFORM_ARCH/$PACKAGE_NAME"
                            ;;
                        *)  die "invalid package spec: $1"
                    esac
                fi

                if [ -z "$USER_SPECIFIED_PACKAGE_SPEC_LIST" ] ; then
                    USER_SPECIFIED_PACKAGE_SPEC_LIST="$PACKAGE_SPEC"
                else
                    USER_SPECIFIED_PACKAGE_SPEC_LIST="$USER_SPECIFIED_PACKAGE_SPEC_LIST $PACKAGE_SPEC"
                fi
        esac
        shift
    done

    if [ "$LOG_LEVEL" -eq "$LOG_LEVEL_QUIET" ] ; then
        exec 1>/dev/null
        exec 2>&1
    fi

    if [ "$LOG_LEVEL" -gt "$LOG_LEVEL_DEBUG" ] ; then
        export PKG_CONFIG_DEBUG_SPEW=set
    fi
}

__setup() {
    if [ -d    "$XCPKG_CORE_DIR" ] ; then
        rm -rf "$XCPKG_CORE_DIR"
    fi

    install -d "$XCPKG_CORE_BIN_DIR"

    #################################################################################

    if [ "$1" = '--use-brew' ] ; then
        __setup_homebrew
    else
        __setup_uppm
    fi

    #################################################################################

    cat > "$XCPKG_CORE_BIN_DIR/base64-encode-string" <<EOF
#!/bin/sh
set -e

if [ -z "\$BASE64_COMMAND" ] ; then
    BASE64_COMMAND=base64
fi

printf '%s\n' "\$@" | "\$BASE64_COMMAND" -w 0
printf '\n'
EOF

    chmod +x "$XCPKG_CORE_BIN_DIR/base64-encode-string"

    #################################################################################

    cat > "$XCPKG_CORE_BIN_DIR/wfetch-url-transform.sample" <<EOF
# https://ghproxy.com/
case \$1 in
    *githubusercontent.com/*)
        printf 'https://ghproxy.com/%s\n' "\$1"
        ;;
    https://github.com/*)
        printf 'https://ghproxy.com/%s\n' "\$1"
        ;;
    '') printf '%s\n' "\$0 <URL>, <URL> is unspecified." >&2 ;;
    *)  printf '%s\n' "\$1"
esac
EOF

    success "xcpkg have been successfully setup."
}

__setup_homebrew() {
    unset BREW; BREW=$(command -v brew || true)

    if [ -z "$BREW" ] ; then
        unset SETUP_WORKING_DIR
        SETUP_WORKING_DIR=$(mktemp -d)

        run curl -L -o "$SETUP_WORKING_DIR/homebrew-install.sh" 'https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh'
        run "yes | bash $SETUP_WORKING_DIR/homebrew-install.sh"

        BREW=$(command -v brew || true)
    else
        run "$BREW" update
    fi

    unset BREW_PACKAGE_EXEFIND_PATH

    for item in coreutils findutils gawk gsed grep gnu-tar gzip lzip unzip zip jq yq git curl tree
    do
        run "$BREW" install "$item"

        unset BREW_PACKAGE_INSTALLED_DIR
        BREW_PACKAGE_INSTALLED_DIR="$(brew --prefix "$item")"

        if [ -d "$BREW_PACKAGE_INSTALLED_DIR/bin" ] ; then
            BREW_PACKAGE_EXEFIND_PATH="$BREW_PACKAGE_EXEFIND_PATH:$BREW_PACKAGE_INSTALLED_DIR/bin"
        fi

        if [ -d "$BREW_PACKAGE_INSTALLED_DIR/sbin" ] ; then
            BREW_PACKAGE_EXEFIND_PATH="$BREW_PACKAGE_EXEFIND_PATH:$BREW_PACKAGE_INSTALLED_DIR/sbin"
        fi

        if [ -d "$BREW_PACKAGE_INSTALLED_DIR/libexec/gnubin" ] ; then
            BREW_PACKAGE_EXEFIND_PATH="$BREW_PACKAGE_EXEFIND_PATH:$BREW_PACKAGE_INSTALLED_DIR/libexec/gnubin"
        fi
    done

    run ln -sf /usr/local/bin/gln      "$XCPKG_CORE_BIN_DIR/ln"
    run ln -sf /usr/local/bin/gtar     "$XCPKG_CORE_BIN_DIR/tar"
    run ln -sf /usr/local/bin/gsed     "$XCPKG_CORE_BIN_DIR/sed"
    run ln -sf /usr/local/bin/gawk     "$XCPKG_CORE_BIN_DIR/awk"
    run ln -sf /usr/local/bin/ggrep    "$XCPKG_CORE_BIN_DIR/grep"
    run ln -sf /usr/local/bin/gfind    "$XCPKG_CORE_BIN_DIR/find"
    run ln -sf /usr/local/bin/gbase64  "$XCPKG_CORE_BIN_DIR/base64"
    run ln -sf /usr/local/bin/gunlink  "$XCPKG_CORE_BIN_DIR/unlink"
    run ln -sf /usr/local/bin/ginstall "$XCPKG_CORE_BIN_DIR/install"
    run ln -sf /usr/local/bin/gsha256sum "$XCPKG_CORE_BIN_DIR/sha256sum"

    ##################################################################################

    cat > "$XCPKG_CORE_DIR/env" <<EOF
XCPKG_USE_BREW=yes

export ACLOCAL_PATH=/usr/local/share/aclocal
export PATH="$BREW_PACKAGE_EXEFIND_PATH:$PATH"
EOF
}

# use commands: uname curl tar gzip xz sed
__setup_uppm() {
    unset FETCH_TOOL

    for FETCH_TOOL in curl wget http lynx aria2c axel
    do
        if command_exists_in_filesystem "$FETCH_TOOL" ; then
            break
        else
            unset FETCH_TOOL
        fi
    done

    if [ -z "$FETCH_TOOL" ] ; then
        error "no any fetch tool[curl, wget, http, lynx, aria2c, axel] found."
        return 1
    else
        unset FETCH_TOOL
    fi

    ##################################################################################

    unset NATIVE_OS_ARCH

    NATIVE_OS_ARCH="$(uname -m)"

    unset SETUP_WORKING_DIR
    SETUP_WORKING_DIR=$(mktemp -d)

    JSON_FILEPATH="$SETUP_WORKING_DIR/latest.json"

    wfetch "https://api.github.com/repos/leleliu008/uppm-package-repository-macos-$NATIVE_OS_ARCH/releases/latest" --output-path="$JSON_FILEPATH"

    FETCH_BASE_URL="https://github.com/leleliu008/uppm-package-repository-macos-$NATIVE_OS_ARCH/releases/download/$(sed -n '/"tag_name":/p' "$JSON_FILEPATH" | sed 's|  "tag_name": "\(.*\)",|\1|')"

    ##################################################################################

    unset UPPM_ARCHIVE_FILENAME
    UPPM_ARCHIVE_FILENAME=$(sed -n '/"name":/p' "$JSON_FILEPATH" | sed -e 's|[[:space:]]||g' -e 's|"name":"\(.*\)",|\1|' | sed -n '/^uppm-/p')
    UPPM_ARCHIVE_FILEPATH="$SETUP_WORKING_DIR/$UPPM_ARCHIVE_FILENAME"

    wfetch "${FETCH_BASE_URL}/${UPPM_ARCHIVE_FILENAME}" --output-path="$UPPM_ARCHIVE_FILEPATH"

    run install -d "$XCPKG_CORE_DIR"

    run tar vxf "$UPPM_ARCHIVE_FILEPATH" --strip-components=1 --no-same-owner -C "$XCPKG_CORE_DIR"

    rm -rf "$XCPKG_CORE_DIR/.xcpkg"

    ##################################################################################

    # https://curl.se/docs/caextract.html
    wfetch 'https://curl.se/ca/cacert.pem' --output-dir="$SETUP_WORKING_DIR"

    run install -d                         "$XCPKG_CORE_DIR/etc/ssl/certs"
    run cp "$SETUP_WORKING_DIR/cacert.pem" "$XCPKG_CORE_DIR/etc/ssl/certs"

    ##################################################################################

    export SSL_CERT_FILE="$XCPKG_CORE_DIR/etc/ssl/certs/cacert.pem"

    UPPM="$XCPKG_CORE_BIN_DIR/uppm"

    run "$UPPM" env
    run "$UPPM" update

    unset UPPM_PACKAGE_EXEFIND_PATH
    unset UPPM_PACKAGE_ACLOCAL_PATH

    for item in coreutils findutils gawk gsed grep gtar gzip lzip unzip zip jq yq git curl tree
    do
        run "$UPPM" install "$item"

        unset UPPM_PACKAGE_INSTALLED_DIR
        UPPM_PACKAGE_INSTALLED_DIR="$("$UPPM" info "$item" installed-dir)"

        if [ -d "$UPPM_PACKAGE_INSTALLED_DIR/bin" ] ; then
            UPPM_PACKAGE_EXEFIND_PATH="$UPPM_PACKAGE_EXEFIND_PATH:$UPPM_PACKAGE_INSTALLED_DIR/bin"
        fi

        if [ -d "$UPPM_PACKAGE_INSTALLED_DIR/sbin" ] ; then
            UPPM_PACKAGE_EXEFIND_PATH="$UPPM_PACKAGE_EXEFIND_PATH:$UPPM_PACKAGE_INSTALLED_DIR/sbin"
        fi

        if [ -d "$UPPM_PACKAGE_INSTALLED_DIR/share/aclocal" ] ; then
            UPPM_PACKAGE_ACLOCAL_PATH="$UPPM_PACKAGE_ACLOCAL_PATH:$UPPM_PACKAGE_INSTALLED_DIR/share/aclocal"
        fi
    done

    cat > "$XCPKG_CORE_DIR/env" <<EOF
XCPKG_USE_BREW=no

export ACLOCAL_PATH="$UPPM_PACKAGE_ACLOCAL_PATH:$ACLOCAL_PATH"
export PATH="$UPPM_PACKAGE_EXEFIND_PATH:$PATH"

# https://git-scm.com/book/en/v2/Git-Internals-Environment-Variables
if [ -d "$HOME/.uppm/installed/git/libexec/git-core" ] ; then
    export GIT_EXEC_PATH="$HOME/.uppm/installed/git/libexec/git-core"
    export GIT_TEMPLATE_DIR="$HOME/.uppm/installed/git/share/git-core/templates"
fi
EOF
}

__help() {
    if command -v base64 > /dev/null ; then
        LOGO_BASE64_ENCODED='ICAgICAgICAgICAgICAgIF8gICAgICAgICAKX18gIF9fX19fIF8gX18gfCB8IF9fX18gXyAKXCBc
LyAvIF9ffCAnXyBcfCB8LyAvIF9gIHwKID4gIDwgKF9ffCB8XykgfCAgIDwgKF98IHwKL18vXF9c
X19ffCAuX18vfF98XF9cX18sIHwKICAgICAgICAgfF98ICAgICAgICB8X19fLyAK'

        if command -v lolcat > /dev/null ; then
            printf '%s\n' "$LOGO_BASE64_ENCODED" | base64 -d | lolcat -S 350
        elif command -v awk > /dev/null ; then
            printf '%s\n' "$LOGO_BASE64_ENCODED" | base64 -d | lolcat_awk
        else
            printf '%b\n' "${COLOR_BLUE}$(printf '%s\n' "$LOGO_BASE64_ENCODED" | base64 -d)${COLOR_OFF}"
        fi
    fi

    echo "
A package manager for Xcode to build C/C++/Rust/Go project.${COLOR_OFF}

${COLOR_GREEN}xcpkg <ACTION> [ARGUMENT...]${COLOR_OFF}

${COLOR_GREEN}xcpkg --help${COLOR_OFF}
${COLOR_GREEN}xcpkg -h${COLOR_OFF}
    show help of this command.

${COLOR_GREEN}xcpkg --version${COLOR_OFF}
${COLOR_GREEN}xcpkg -V${COLOR_OFF}
    show version of this command.

${COLOR_GREEN}xcpkg env [-v]${COLOR_OFF}
    show your system and Xcode information.

${COLOR_GREEN}xcpkg sysinfo${COLOR_OFF}
    show your system information.

${COLOR_GREEN}xcpkg xcinfo${COLOR_OFF}
    show your Xcode information.

    If ${COLOR_PURPLE}DEVELOPER_DIR${COLOR_OFF} environment variable is set, xcpkg will use it, otherwize, run command ${COLOR_PURPLE}xcode-select -p${COLOR_OFF} to determine.

${COLOR_GREEN}xcpkg integrate zsh [-v]${COLOR_OFF}
    download a zsh-completion script file to a approprivate location.

${COLOR_GREEN}xcpkg update${COLOR_OFF}
    update all available formula repositories.

${COLOR_GREEN}xcpkg cleanup${COLOR_OFF}
    delete the unused cached files.

${COLOR_GREEN}xcpkg ls-target-platforms${COLOR_OFF}
    list the supported target platforms.

${COLOR_GREEN}xcpkg ls-target-versions [PLATFORM]${COLOR_OFF}
    list the supported target platform's version.

${COLOR_GREEN}xcpkg ls-target-triples [32bit|64bit|all]${COLOR_OFF}
    list the supported target triples.

${COLOR_GREEN}xcpkg ls-target-archs   [32bit|64bit|all] [PLATFORM]${COLOR_OFF}
    list the supported target archs.

${COLOR_GREEN}xcpkg ls-available${COLOR_OFF}
    list all available packages.

${COLOR_GREEN}xcpkg ls-installed${COLOR_OFF}
    list all installed packages.

${COLOR_GREEN}xcpkg ls-outdated${COLOR_OFF}
    list all outdated  packages.

${COLOR_GREEN}xcpkg is-available <PACKAGE-SPEC>${COLOR_OFF}
    check if the given package is available.

${COLOR_GREEN}xcpkg is-installed <PACKAGE-SPEC>${COLOR_OFF}
    check if the given package is installed.

${COLOR_GREEN}xcpkg is-outdated  <PACKAGE-SPEC>${COLOR_OFF}
    check if the given package is outdated.

${COLOR_GREEN}xcpkg search <REGULAR-EXPRESS-PATTERN>${COLOR_OFF}
    search all available packages whose name matches the given regular express pattern.

${COLOR_GREEN}xcpkg formula-view <PACKAGE-NAME>${COLOR_OFF}
    view the formula of the given package.

${COLOR_GREEN}xcpkg formula-edit <PACKAGE-NAME>${COLOR_OFF}
    edit the formula of the given package.

${COLOR_GREEN}xcpkg formula-list${COLOR_OFF}
    list all formulas.

${COLOR_GREEN}xcpkg formula-repo [list]${COLOR_OFF}
    list all available formula repositories.

${COLOR_GREEN}xcpkg formula-repo-add <NAME> <URL>${COLOR_OFF}
    add a new formula-repo.

${COLOR_GREEN}xcpkg formula-repo-del <NAME>${COLOR_OFF}
    delete a exist formula-repo.

${COLOR_GREEN}xcpkg tree <PACKAGE-SPEC> [--dirsfirst | -L N]${COLOR_OFF}
    list installed files of the given installed package in a tree-like format.

${COLOR_GREEN}xcpkg pack <PACKAGE-SPEC> [--keep-packing-dir] [-t <zip|tar.gz|tar.xz|tar.lz|tar.bz2>] [-o <OUTPUT-PATH>]${COLOR_OFF}
    pack the given installed package.

    <OUTPUT-PATH> can be either the filepath or directory where the packed archive will be written to. If <OUTPUT-PATH> is an existing directory or ends with slash, then it will be treated as a directory, otherwize, it will be treated as a filepath.

    If -t <OUTPUT-TYPE> option is not given but -o <OUTPUT-PATH> option is given, if <OUTPUT-PATH> is treated as a filepath, then <OUTPUT-PATH> must ends with one of .tar.gz|.tar.xz|.tar.lz|.tar.bz2|.tgz|.txz|.tlz|.tbz2|zip

    If -t <OUTPUT-TYPE> option is not given but -o <OUTPUT-PATH> option is given, if <OUTPUT-PATH> is treated as a directory, then <OUTPUT-TYPE> will be .tar.xz, OUTPUT-PATH will be expanded to <OUTPUT-PATH>/\$XCPKG_HOME/packed/\$PACKAGE_NAME-\$PACKAGE_VERSION-\$TARGET_PLATFORM_NAME-\$TARGET_PLATFORM_ARCH.tar.xz

    If -t <OUTPUT-TYPE> and -o <OUTPUT-PATH> options both are not given, <OUTPUT-TYPE> will be .tar.xz, OUTPUT-PATH will be \$XCPKG_HOME/packed/\$PACKAGE_NAME-\$PACKAGE_VERSION-\$TARGET_PLATFORM_NAME-\$TARGET_PLATFORM_ARCH.tar.xz

${COLOR_GREEN}xcpkg logs <PACKAGE-SPEC>${COLOR_OFF}
    show logs of the given installed package.

${COLOR_GREEN}xcpkg info <PACKAGE-NAME|PACKAGE-SPEC> [KEY]${COLOR_OFF}
    show information of the given package.

${COLOR_GREEN}xcpkg info @all [--json|--yaml|--shell]${COLOR_OFF}
    show information of all the available packages.

${COLOR_GREEN}xcpkg fetch <PACKAGE-NAME>${COLOR_OFF}
    download resources of the given package to the local cache.

${COLOR_GREEN}xcpkg depends <PACKAGE-NAME> [-t <dot|box|svg|png>] [-o <OUTPUT-PATH>]${COLOR_OFF}
    show the packages that are depended by the given package.

    <OUTPUT-PATH> can be either the filepath or directory where the file will be written to. If <OUTPUT-PATH> is an existing directory or ends with slash, then it will be treated as a directory, otherwize, it will be treated as a filepath.

    If -t <OUTPUT-TYPE> option is not given but -o <OUTPUT-PATH> option is given, if <OUTPUT-PATH> is treated as a directory, then <OUTPU-TYPE> will be box and <OUTPUT-PATH> will be expanded to <OUTPUT-PATH>/<PACKAGE-NAME>-dependencies.box

    If -t <OUTPUT-TYPE> option is not given but -o <OUTPUT-PATH> option is given, if <OUTPUT-PATH> is treated as a filepath, then <OUTPUT-PATH> must ends with one of .dot|.box|.svg|.png

    If -t <OUTPUT-TYPE> and -o <OUTPUT-PATH> options both are not given, <OUTPU-TYPE> will be box and output to stdout.

${COLOR_GREEN}xcpkg install   <PACKAGE-SPEC>... [--jobs=N -v -d -q --dry-run --keep-working-dir]${COLOR_OFF}
    install the given packages.

${COLOR_GREEN}xcpkg reinstall <PACKAGE-SPEC>... [--jobs=N -v -d -q --dry-run --keep-working-dir]${COLOR_OFF}
    reinstall the given packages.

${COLOR_GREEN}xcpkg upgrade   [PACKAGE-SPEC]... [--jobs=N -v -d -q --dry-run --keep-working-dir]${COLOR_OFF}
    upgrade the given outdated packages.

${COLOR_GREEN}xcpkg upgrade-self${COLOR_OFF}
    upgrade this software.

${COLOR_GREEN}xcpkg uninstall <PACKAGE-SPEC>...${COLOR_OFF}
    uninstall the given packages.

${COLOR_GREEN}xcpkg create-framework <PACKAGE>...${COLOR_OFF}
    create framework for packages.


${COLOR_GREEN}PACKAGE-SPEC:${COLOR_OFF}
    a formatted srting that has form: <TARGET-PLATFORM-SPEC>/<PACKAGE-NAME>

${COLOR_GREEN}TARGET-PLATFORM-SPEC:${COLOR_OFF}
    a formatted srting that has form: <PLATFORM-NAME>/<PLATFORM-VERSION>/<PLATFORM-ARCH>
    indicates which platform should be built for.

${COLOR_GREEN}PLATFORM-VERSION:${COLOR_OFF}
    the minimum version supported by this package.

${COLOR_GREEN}PLATFORM-NAME:${COLOR_OFF}
    xcpkg ls-target-platforms command will list the supported platform names.

${COLOR_GREEN}PACKAGE-NAME:${COLOR_OFF}
    must match regular expression pattern ^[A-Za-z0-9+-._]{1,50}$
    "

    if [ -z "$1" ] ; then
        exit
    else
        exit "$1"
    fi
}

main() {
    set -e

    [ -n "$XCPKG_XTRACE" ] && set -x

    [ "$(uname)" = 'Darwin' ] || die "this software can only be run on macOS."

    unset NATIVE_OS_KIND
    unset NATIVE_OS_TYPE
    unset NATIVE_OS_VERS
    unset NATIVE_OS_ARCH
    unset NATIVE_OS_NCPU

    NATIVE_OS_KIND=darwin
    NATIVE_OS_TYPE=macos
    NATIVE_OS_VERS="$(sw_vers -productVersion)"
    NATIVE_OS_ARCH="$(uname -m)"
    NATIVE_OS_NCPU="$(sysctl -n machdep.cpu.thread_count)"
    NATIVE_OS_EUID="$(id -u)"
    NATIVE_OS_EGID="$(id -g)"

    XCPKG="$CURRENT_SCRIPT_FILEPATH"

    XCPKG_VERSION=0.10.0

    XCPKG_WEB_URL='https://github.com/leleliu008/xcpkg'

    XCPKG_OFFICAL_FORMULA_REPO_URL='https://github.com/leleliu008/xcpkg-formula-repository-offical-core'

    XCPKG_UPGRAGE_URL='https://raw.githubusercontent.com/leleliu008/xcpkg/master/bin/xcpkg'

    [ -z "$XCPKG_HOME" ] && {
        if [ -z "$HOME" ] ; then
            die "HOME environment variable is not set."
        else
            XCPKG_HOME="$HOME/.xcpkg"
        fi
    }

    XCPKG_FORMULA_REPO_DIR="$XCPKG_HOME/repos.d"

    XCPKG_PACKAGE_INSTALLED_ROOT="$XCPKG_HOME/installed"
    XCPKG_PACKAGE_SYMLINKED_ROOT="$XCPKG_HOME/symlinked"

    XCPKG_DOWNLOADS_DIR="$XCPKG_HOME/downloads"

    XCPKG_BACKUP_DIR="$XCPKG_HOME/backup.d"

    XCPKG_CORE_DIR="$XCPKG_HOME/core"
    XCPKG_CORE_BIN_DIR="$XCPKG_CORE_DIR/bin"

    unset TIMESTAMP_UNIX; TIMESTAMP_UNIX="$(date +%s)"

    case $1 in
        ''|--help|-h)
            __help
            return 0
            ;;
        --version|-V)
            printf '%s\n' "$XCPKG_VERSION"
            return 0
            ;;
        setup)
            shift
            __setup $@
            return 0
            ;;
        sysinfo)
            cat <<EOF
sysinfo.ncpu: $NATIVE_OS_NCPU
sysinfo.arch: $NATIVE_OS_ARCH
sysinfo.kind: $NATIVE_OS_KIND
sysinfo.type: $NATIVE_OS_TYPE
sysinfo.vers: $NATIVE_OS_VERS
sysinfo.euid: $NATIVE_OS_EUID
sysinfo.egid: $NATIVE_OS_EGID
EOF
            return 0;
            ;;
        xcinfo)
            inspect_xcode_information

            cat <<EOF
xcode-root: $TOOLCHAIN_ROOT
xcode-vers: $TOOLCHAIN_VERS

tools:
    CC:      $TOOLCHAIN_BIND/clang
    CXX:     $TOOLCHAIN_BIND/clang++
    CPP:     $TOOLCHAIN_BIND/cpp
    AS:      $TOOLCHAIN_BIND/as
    AR:      $TOOLCHAIN_BIND/ar
    RANLIB:  $TOOLCHAIN_BIND/ranlib
    LD:      $TOOLCHAIN_BIND/ld
    NM:      $TOOLCHAIN_BIND/nm
    STRIP:   $TOOLCHAIN_BIND/strip
    SIZE:    $TOOLCHAIN_BIND/size
    STRINGS: $TOOLCHAIN_BIND/strings
    OBJDUMP: $TOOLCHAIN_BIND/objdump

platforms:
    MacOSX:
        SDKROOT: $(xcrun --sdk macosx --show-sdk-path)
        supported:
            archs: $(__list_supported_target_archs MacOSX)
            versions: $(__list_supported_target_platform_versions MacOSX)

    WatchOS:
        SDKROOT: $(xcrun --sdk watchos --show-sdk-path)
        supported:
            archs: $(__list_supported_target_archs WatchOS)
            versions: $(__list_supported_target_platform_versions WatchOS)

    WatchSimulator:
        SDKROOT: $(xcrun --sdk watchsimulator --show-sdk-path)
        supported:
            archs: $(__list_supported_target_archs WatchSimulator)
            versions: $(__list_supported_target_platform_versions WatchSimulator)

    iPhoneOS:
        SDKROOT: $(xcrun --sdk iphoneos --show-sdk-path)
        supported:
            archs: $(__list_supported_target_archs iPhoneOS)
            versions: $(__list_supported_target_platform_versions iPhoneOS)

    iPhoneSimulator:
        SDKROOT: $(xcrun --sdk iphonesimulator --show-sdk-path)
        supported:
            archs: $(__list_supported_target_archs iPhoneSimulator)
            versions: $(__list_supported_target_platform_versions iPhoneSimulator)

    AppleTVOS:
        SDKROOT: $(xcrun --sdk appletvos --show-sdk-path)
        supported:
            archs: $(__list_supported_target_archs AppleTVOS)
            versions: $(__list_supported_target_platform_versions AppleTVOS)

    AppleTVSimulator:
        SDKROOT: $(xcrun --sdk appletvsimulator --show-sdk-path)
        supported:
            archs: $(__list_supported_target_archs AppleTVSimulator)
            versions: $(__list_supported_target_platform_versions AppleTVSimulator)
EOF
            return 0;
            ;;
    esac

    if [ -f "$XCPKG_CORE_DIR/env" ] ; then
        .   "$XCPKG_CORE_DIR/env"
    else
        die "please run ${COLOR_GREEN}$_0 setup${COLOR_OFF} command first, then try again."
    fi

    # https://www.gnu.org/software/automake/manual/html_node/Macro-Search-Path.html
    if [ -z "$ACLOCAL_PATH" ] ; then
        export ACLOCAL_PATH="$XCPKG_CORE_DIR/share/aclocal"
    else
        export ACLOCAL_PATH="$XCPKG_CORE_DIR/share/aclocal:$ACLOCAL_PATH"
    fi

    # https://www.openssl.org/docs/man1.1.1/man3/SSL_CTX_set_default_verify_paths.html
    if [ -f "$XCPKG_CORE_DIR/etc/ssl/certs/cacert.pem" ] ; then
        export SSL_CERT_FILE="$XCPKG_CORE_DIR/etc/ssl/certs/cacert.pem"
    fi

    # pip install --user <PKG>
    bppend_to_PATH "$HOME/.local/bin"

    # cpan install to default local location
    bppend_to_PATH "$HOME/perl5/bin"

    if [ -f "$HOME/.cargo/env" ] ; then
        .   "$HOME/.cargo/env"
    fi

    bppend_to_PATH "$XCPKG_CORE_BIN_DIR"

    case $1 in
        env)
            cat <<EOF
sysinfo.ncpu: $NATIVE_OS_NCPU
sysinfo.arch: $NATIVE_OS_ARCH
sysinfo.kind: $NATIVE_OS_KIND
sysinfo.type: $NATIVE_OS_TYPE
sysinfo.vers: $NATIVE_OS_VERS
sysinfo.euid: $NATIVE_OS_EUID
sysinfo.egid: $NATIVE_OS_EGID

xcpkg.vers : $XCPKG_VERSION
xcpkg.home : $XCPKG_HOME
xcpkg.path : $XCPKG
xcpkg.link : https://github.com/leleliu008/xcpkg
EOF
            if [ "$XCPKG_USE_BREW" = yes ] ; then
                run brew --version
                run brew --env
            else
                run uppm env
            fi

            inspect_xcode_information

            cat <<EOF

xcode.root: $TOOLCHAIN_ROOT
xcode.vers: $TOOLCHAIN_VERS
EOF
            if [ "$2" = '-v' ] ; then
                echo "${COLOR_PURPLE}==>${COLOR_OFF} ${COLOR_GREEN}PATH${COLOR_OFF}"
                printf '%s\n' "$PATH" | tr : '\n'
            fi
            ;;

        ls-target-platforms) shift; __list_supported_target_platforms $@ ;;
        ls-target-versions)  shift; __list_supported_target_platform_versions  $@ ;;
        ls-target-triples)   shift; __list_supported_target_triples   $@ ;;
        ls-target-archs)     shift; __list_supported_target_archs     $@ ;;

        ls-available) shift; __list_available_packages ;;
        ls-installed) shift; __list_installed_packages ;;
        ls-outdated)  shift; __list__outdated_packages ;;

        is-available) shift; is_package_available $@ ;;
        is-installed) shift; is_package_installed $@ ;;
        is-outdated)  shift; is_package__outdated $@ ;;

        formula-repo)
            shift
            case $1 in
                list) shift; __list_available_formula_repository_items ;;
                add)  shift; __add_a_formula_repo $@ ;;
                del)  shift; __del_a_formula_repo $@ ;;
                *) help 1
            esac
            ;;
        formula)
            shift
            case $1 in
                create) shift; __create_formula_of_the_given_package $@ ;;
                delete) shift; __delete_formula_of_the_given_package $@ ;;
                rename) shift; __rename_formula_of_the_given_package $@ ;;
                view)   shift;   __view_formula_of_the_given_package $@ ;;
                edit)   shift;   __edit_formula_of_the_given_package $@ ;;
                list)   shift; __list_formula_filepath ;;
                   *)   help 1
            esac
            ;;
        update)  __update_formula_repositories ;;
        cleanup) __cleanup ;;

        min-version) shift; get_supported_min_version $1 ;;

        search)  shift; __search_packages "$*" ;;

          install) shift;   __install_the_given_packages $@ ;;
        reinstall) shift; __reinstall_the_given_packages $@ ;;
        uninstall) shift; __uninstall_the_given_packages $@ ;;

        upgrade)   shift; __upgrade_packages $@ ;;
        upgrade-self)
            shift
            __upgrade_self "$XCPKG_UPGRAGE_URL" $@
            ;;
        integrate)
            shift
            case $1 in
                zsh) shift; __integrate_zsh_completions 'https://raw.githubusercontent.com/leleliu008/xcpkg/master/zsh-completion/_xcpkg' $@ ;;
                *)   die "xcpkg integrate $1: not support."
            esac
            ;;
        depends)
            shift
            __show_packages_depended_by_the_given_package $@
            ;;
        fetch)
            shift
            __fetch_resources_of_the_given_package $@
            ;;
        logs) shift; __logs_the_given_installed_package $@ ;;
        pack) shift; __pack_the_given_installed_package $@ ;;
        tree) shift; __tree_the_given_installed_package $@ ;;

        info)
            shift
            __show_information_of_the_given_package $@
            ;;
        create-framework)
            shift
            __create_framework_for_the_given_packages $@
            ;;
        gen-github-workflows)
            shift
            __gen_github_workflows $@
            ;;
        compare-versions)
            __compare_versions_with_brew
            ;;
        *)  die "unrecognized argument: $1"
    esac
}

main $@
